<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="preconnect" href="https://www.google-analytics.com">
<script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-139640266-2","auto"),ga("send","pageview")</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
<link rel="search" type="application/opensearchdescription+xml" title="Agora-cl" href="/opensearch.xml">
<script src="https://buttons.github.io/buttons.js"></script><title data-react-helmet="true">Optimistic sync | Agora-cl</title><meta data-react-helmet="true" property="og:url" content="https://agora-cl-docs.bosagora.io/docs/how-agora-cl-works/optimistic-sync"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="Optimistic sync | Agora-cl"><meta data-react-helmet="true" name="description" content="This content was previously published on HackMD. The version you&#x27;re reading now is the version that we&#x27;re maintaining."><meta data-react-helmet="true" property="og:description" content="This content was previously published on HackMD. The version you&#x27;re reading now is the version that we&#x27;re maintaining."><link data-react-helmet="true" rel="shortcut icon" href="/img/bosagora-logo.png"><link data-react-helmet="true" rel="canonical" href="https://agora-cl-docs.bosagora.io/docs/how-agora-cl-works/optimistic-sync"><link data-react-helmet="true" rel="alternate" href="https://agora-cl-docs.bosagora.io/docs/how-agora-cl-works/optimistic-sync" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://agora-cl-docs.bosagora.io/docs/how-agora-cl-works/optimistic-sync" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.9b7cbe7b.css">
<link rel="preload" href="/assets/js/runtime~main.bf2263fc.js" as="script">
<link rel="preload" href="/assets/js/main.a87cd8b8.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/docs/getting-started"><img src="/img/bosagora-logo.png" alt="logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/bosagora-logo.png" alt="logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Agora-cl Documentation</b></a><a href="https://github.com/zeroone-boa/agora-cl/releases/tag/v3.1.1" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">agora_v3.1.1</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/install/install-with-script">Quick Install</a><a href="https://github.com/zeroone-boa/agora-cl" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://t.me/bosagora_eng" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>Telegram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">ðŸŒž</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_1ZXk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/getting-started">Table of contents</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/install/install-with-script">Quickstart: Run a node</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/prepare-for-merge">Prepare for The Merge</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/security-best-practices">Security best practices</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/agora-cl-usage/parameters">Command-line options</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/monitoring/checking-status">Check node and validator status</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/troubleshooting/issues-errors">Troubleshooting</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Advanced installation guides</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">How-tos</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Concepts</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Developer wiki</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/contribute/contribution-guidelines">Contribute to Agora-cl&#x27;s codebase</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/contribute/golang-principles">Golang principles</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/reading/golang">Golang resources</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/reading/bazel">About Bazel</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">APIs</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">Developer concepts</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/devtools/init-state">Initial synchronization</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/devtools/net-design">Network design</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/devtools/extending-apis">Extending APIs</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/architecture-overview">Architecture overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/agora-cl node">Beacon node</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/agora-cl-validator-client">Validator client</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/validator-lifecycle">Validator lifecycle</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/how-agora-cl-works/optimistic-sync">Optimistic sync</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/validator-deposit-contract">Validator deposit contract</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/database-backend-boltdb">BoltDB database</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/p2p-networking">P2P networking</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/how-agora-cl-works/bls-cryptography">BLS cryptography</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/devtools/end-to-end">End-to-end tests</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Misc</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/faq">Frequently asked questions</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/terminology">Glossary</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">Optimistic sync</h1></header><div class="admonition admonition-info alert alert--info"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</h5></div><div class="admonition-content"><p>This content was previously <a href="https://hackmd.io/5NhsX8FvSm2GqESpdpe-Vg?view" target="_blank" rel="noopener noreferrer">published on HackMD</a>. The version you&#x27;re reading now is the version that we&#x27;re maintaining.</p></div></div><p>In this document we cover optimistic sync and its detailed implementation in Agora-cl. We explain the numerous subtle edge cases that arise because of it and the mitigation factors to some attacks that arise when several nodes are optimistic. We start with a high level introduction to what optimistic sync is and how it is specified, and then move to the specific details within Agora-cl&#x27;s implementation.</p><p>We describe Agora-cl&#x27;s API to deal with optimistic sync, describing what the involved functions do, but not <strong>how they do it</strong>. For example, we describe that <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/forkchoice/doubly-linked-tree/optimistic_sync.go#L10" target="_blank" rel="noopener noreferrer">SetOptimisticToInvalid</a> prunes invalid nodes from the forkchoice tree, but do not explain how this pruning is achieved.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-what-is-optimistic-sync"></a>1 What is optimistic sync?<a class="hash-link" href="#1-what-is-optimistic-sync" title="Direct link to heading">#</a></h2><p>Simply put, optimistic sync allows a consensus layer client (CLC) to import, process, and consider a beacon block for its forkchoice head, even though it has not validated its execution payload. Thus, syncing this block <em>optimistically</em> hoping that the block will be eventually validated by the execution layer client (ELC).</p><p>Optimistic sync was devised because of the different mechanisms utilized by the CLC and the ELC to sync. Most ELC use a syncing mechanism called <em>snap sync</em> by which they download a snapshot of the current state from their P2P network, and then proceed to download backwards the blocks and transactions filling its history. Since after the merge, the CLC drives the ELC, without a mechanism to allow the execution layer to sync independently from the consensus layer, it would never catch up to head. The most obvious alternative, known as <em>lockstep syncing</em> consists of starting with a synced state, and importing one block at a time, importing first from the consensus layer and passing down the execution payload to the execution layer. Current sync block times show that syncing a small network like Kiln would take over a couple of weeks in lockstep mode on a decent server. There is a more sensible alternative to optimistic sync using the <em>Light client protocol</em> which we will not cover in this document.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="the-happy-case"></a>The happy case<a class="hash-link" href="#the-happy-case" title="Direct link to heading">#</a></h3><p>From the user&#x27;s perspective, the overwhelming majority of nodes that are  optimistically syncing are nodes that have just been started. The CLC can use checkpoint sync and be in sync in under 2 minutes. Snapshot sync for the ELC on the other hand will take much longer. Until the ELC catches up on head, the CLC may continue to import and keep syncing the beaconchain in optimistic mode. There are few edge cases in this situation. All edge cases and subtle considerations happen when an otherwise synced node, falls into optimistic sync due to an unforeseen circumstance.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-specification"></a>2 Specification<a class="hash-link" href="#2-specification" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="21-which-blocks-can-be-imported-optimistically"></a>2.1 Which blocks can be imported optimistically?<a class="hash-link" href="#21-which-blocks-can-be-imported-optimistically" title="Direct link to heading">#</a></h3><p>The specification of optimistic sync is fairly simple. A node makes the following validations on a beacon block to decide if it can be imported or not into its forkchoice/database. If the block fails consensus validation (signature, operations, right proposer, etc, but excluding execution payload validation), then reject the block and do not import it. Assuming that we have a beacon block that passes this validation. The following blocks are allowed to be imported:</p><ul><li>If the block is pre-merge (ie. it does not include an execution payload).</li><li>If the parent of the block is post-merge (ie. it does include an execution payload).</li></ul><p>This leaves only a merge block itself unaccounted for, that is a block which does include an execution payload, but it is the <strong>first</strong> block in the chain to do so. In this case an extra rule is applied:</p><ul><li>If the block&#x27;s slot is old enough, it is allowed to be imported. Here <em>old enough</em> means that the block slot is lower than the current wall time slot by at least <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> which in the current spec defaults to 128 slots.</li></ul><p>This last rule, which is the only rule from the consensus layer side preventing a node from importing a block, is to mitigate an attack known as the <em>forkchoice poisoning attack</em> which we will cover below in section <a href="#24-forkchoice-poisoning">2.4</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="22-the-engine-api"></a>2.2 The engine API<a class="hash-link" href="#22-the-engine-api" title="Direct link to heading">#</a></h3><p>When the CLC receives a block with an embedded execution payload, it notifies the ELC via two different engine API RPC calls: <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_newpayloadv1" target="_blank" rel="noopener noreferrer">engine_newPayloadv1</a> and <a href="https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_forkchoiceupdatedv1" target="_blank" rel="noopener noreferrer">engine_forkchoiceUpdateV1</a>. These are wrapped internally within Agora-cl in the blockchain&#x27;s package methods <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/execution_engine.go#L160" target="_blank" rel="noopener noreferrer">notifyNewPayload</a> and <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/execution_engine.go#L36" target="_blank" rel="noopener noreferrer">notifyForkchoiceUpdate</a>. These functions are used in different stages of block processing and have different semantics for the ELC. We call <code>notifyNewPayload</code> to inform the ELC that this payload is available and request its validation. We call <code>notifyForkchoceUpdate</code> to inform the ELC that our head has changed and that it should react accordingly (changing the current execution state, the list of canonical blocks, etc).</p><p>When Agora-cl receives a block, after the pubsub validation, and assuming regular sync, it enters the blockchain package via the function <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/receive_block.go#L38" target="_blank" rel="noopener noreferrer">ReceiveBlock</a> and eventually <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block.go#L96" target="_blank" rel="noopener noreferrer">onBlock</a> is called. At this stage, the consensus aspects of this block have been verified. We call <code>notifyNewPayload</code> and await the return of the ELC. There are five possible outcomes of this call:</p><ol><li>VALID</li><li>INVALID</li><li>ACCEPTED/SYNCING</li><li>Timeout (the ELC has not replied)</li><li>Error (something went wrong in the call)</li></ol><p>Dealing with each one of them requires a different set of careful considerations, roughly ordered by level of difficulty. When we receive <code>VALID</code> as a reply, we can simply import the block, this block is not optimistic as it has been fully validated.</p><p>When we receive <code>INVALID</code> a series of checks need to be carried out, we will go over them in the following sections of this document. It suffices to say that for a non-optimistic node (ie. a node that has been syncing in lockstep) when it receives an <code>INVALID</code> response from this call, its processing is very simple: we just do not import this block, it has failed validation, we mark the block as invalid and <code>onBlock</code> (and subsequently <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/receive_block.go#L380" target="_blank" rel="noopener noreferrer">ReceiveBlock</a>) will return with an error, without affecting core logic. What triggers optimistic sync is the response in 3) ACCEPTED/SYNCING. Both replies are treated in the exact same way by Agora-cl, but it is useful to understand the different semantics from the point of view of the ELC. Suppose we are following a chain that is following like this:</p><p><img src="https://i.imgur.com/wMobZC2.png"></p><p>Our head is <code>D</code>, and the ELC has returned <code>VALID</code>  for it when we called
<code>notifyForkchoiceUpdated</code>  to inform that our head had changed to <code>D</code>. We now receive a block in a side chain, orphaning <code>D</code> and <code>C</code>:</p><p><img src="https://i.imgur.com/sYz9uRQ.png"></p><p>Regardless of what happened to our forkchoice, as we first call <code>notifyNewPayload</code>  before making any head considerations, our head will still be <code>D</code>  at the moment of calling <code>notifyNewPayload</code>. Different ELC will return different replies here. They are not required to execute and validate the block <code>F</code> as it does not extend their canonical chain. Some will do anyway, and thus can return VALID / INVALID if they executed the payload completely. Others will simply check that the timestamps, parent block hash and similar header numbers are consistent and will return ACCEPTED, indicating that the block <code>F</code> is ready to be executed but hasn&#x27;t been fully validated yet. Another option is if the ELC does not have the execution payload of the block <code>E</code>  for some reason. In this case the ELC will return SYNCING and it may or may not trigger a request for this block. Either way, a reply of ACCEPTED or SYNCING means that there is nothing evidently wrong with the block, that we may go ahead and import it optimistically, and we will eventually validate it if it is necessary.</p><p>If the block <code>F</code> is therefore ACCEPTED or SYNCING, we will run the checks in section <a href="#21-which-blocks-can-be-imported-optimistically">2.1</a> and import it if it satisfies those conditions.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="23-optimistic-node"></a>2.3 Optimistic Node<a class="hash-link" href="#23-optimistic-node" title="Direct link to heading">#</a></h3><p>It may happen that after importing this block <code>F</code> it becomes head. In this case we will inform the ELC by calling <code>notifyForkchoiceUpdated</code>. The engine is now <strong>required</strong> to execute and validate block <code>F</code> if it hasn&#x27;t done so already. Some engines (eg geth) would have already validated the block if the fork was not long enough. In this case they will return immediately VALID / INVALID. Other engines may not have executed it, specifically, if they haven&#x27;t executed even block <code>E</code>, or if they do not even have block <code>E</code>, they will return SYNCING. In this case, the CLC has already imported the block <code>F</code>, which is now its current head, and it has been imported optimistically. When this happens we say that <strong>the node is optimistic</strong>.</p><mark>An optimistic node may not act on its head: it cannot propose a block, it cannot attest to an optimistic head and cannot sign sync committee duties.</mark> It may (and should) however gossip optimistic blocks.<h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="24-forkchoice-poisoning"></a>2.4 Forkchoice Poisoning<a class="hash-link" href="#24-forkchoice-poisoning" title="Direct link to heading">#</a></h3><p>We mentioned above a subtle condition preventing a node from optimistically syncing the merge block. This attack happens as follows. Suppose we have a forkchoice situation like the following diagram:</p><p><img src="https://i.imgur.com/DVcZili.jpg"></p><p>An attacker is able to propose a block <code>A</code> which satisfies:</p><ul><li>It is the merge block</li><li>It&#x27;s parent execution block is invalid or non-existent</li><li>It justifies a new checkpoint in the beacon-chain</li></ul><p>A node that is optimistically syncing the Agora chain in this conditions will not be able to follow any other chain until the network justifies a higher checkpoint. The reason is the way we decide our head in the forkchoice package: we choose among the tips of the forkchoice tree, those that have the higher justification first. For more details on this procedure you can look at the slides in <a href="https://drive.google.com/file/d/1aiUIVjPEGUv9iNESHaSfFN4DfLgba8al/view?usp=sharing" target="_blank" rel="noopener noreferrer">this video</a>.  Any other block imported in a separate branch will not be considered for head unless it also justifies a higher point. An honest validator following this invalid chain will not be able to leave optimistic mode unless the chain justifies a higher point: it can&#x27;t fully sync since the ELC cannot find the parent of the merge block, and it can&#x27;t jump head because it can&#x27;t choose a lower justification point.</p><p>With the assumption that the majority of the chain will justify a checkpoint after the merge in less than <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code>, then it is safe to import optimistically the merge block, knowing that at least this many slots have passed and we will have an honest justified checkpoint available to jump, in case this merge block is not valid.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-implementation-in-agora-cl"></a>3 Implementation in Agora-cl<a class="hash-link" href="#3-implementation-in-agora-cl" title="Direct link to heading">#</a></h2><p>Agora-cl&#x27;s implementation of optimistic sync involves several different packages. It principally touches the forkchoice and blockchain packages as it changes the core handling of beacon blocks. But it also touches the database (package kv) and the sync package (during init sync and pubsub validation) and the RPC endpoints.  In this section we will cover all the paths added in each package.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="31-forkchoice-package"></a>3.1 Forkchoice package<a class="hash-link" href="#31-forkchoice-package" title="Direct link to heading">#</a></h3><p>The forkchoice package keeps track of the optimistic status of each node. This is required as an optimistic node cannot perform its duties. When inserting a node, it is by default considered optimistic. Its status can be changed to fully validated with the function <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/forkchoice/doubly-linked-tree/forkchoice.go#L378" target="_blank" rel="noopener noreferrer">SetOptimisticToValid</a>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">func</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">f </span><span class="token operator">*</span><span class="token plain">ForkChoice</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">SetOptimisticToValid</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">ctx context</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">Context</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> root </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">fieldparams</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">RootLength</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token builtin" style="color:rgb(189, 147, 249)">byte</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(189, 147, 249)">error</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>This function simply takes the HTR of the block and it sets its optimistic status to VALID. It also sets the optimistic status of any ancestor to VALID since a block cannot be fully validated if its ancestors weren&#x27;t.</p><p>If a block that was imported optimistically later becomes INVALID, this can be notified with the function <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/forkchoice/doubly-linked-tree/optimistic_sync.go#L10" target="_blank" rel="noopener noreferrer">SetOptimisticToInvalid</a>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">func</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">s </span><span class="token operator">*</span><span class="token plain">Store</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">setOptimisticToInvalid</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">ctx context</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">Context</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> root</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> parentRoot</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> payloadHash </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">32</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token builtin" style="color:rgb(189, 147, 249)">byte</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">32</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token builtin" style="color:rgb(189, 147, 249)">byte</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(189, 147, 249)">error</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>The reader will notice that the signature of this function is different. The reason is that when the ELC returns INVALID from <code>notifyNewPayload</code> , it also returns the latest valid hash (LVH), that is, the payload hash of the unique execution block that satisfies the following two conditions:</p><ul><li>It is a VALID ancestor of the INVALID payload</li><li>Any ancestor of the INVALID payload, with a higher <code>blockNumber</code>, is INVALID</li></ul><p>The INVALID payload itself may or may not be in the forkchoice store, in fact, it will <strong>almost never</strong> be, since we only call <code>notifyNewPayload</code> with new blocks before we insert them to forkchoice. The function <code>setOptimisticToInvalid</code> takes as parameters the root of the INVALID block, the root of its parent block, and the LVH. It works by first finding the unique block satisfying the following conditions:</p><ul><li>It is a child of the LVH</li><li>It is an ancestor of the INVALID payload</li></ul><p>And then it removes that block and <strong>every descentant</strong> of it. This is strictly true in the <code>doubly-linked-tree</code>  implementation of forkchoice. But this is not the case in the <code>protoarray</code> implementation. Removing nodes from the <code>protoarray</code> implementation is complicated. Thus what we do in this case is mark the nodes as INVALID instead. After removal of the nodes, the weights of the remaining forkchoice tree needs to be readjusted. The function returns the blockroots of all the removed nodes (or those nodes marked as invalid in the <code>protoarray</code> implementation).</p><p>The <code>doublylinkedtree.Node</code> structure has a boolean <code>optimistic</code>:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> Node </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    slot                     types</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">Slot                   </span><span class="token comment" style="color:rgb(98, 114, 164)">// slot of the block converted to the node.</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><span class="token operator">...</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    optimistic               </span><span class="token builtin" style="color:rgb(189, 147, 249)">bool</span><span class="token plain">                         </span><span class="token comment" style="color:rgb(98, 114, 164)">// whether the block has been fully validated or not</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>That is <code>true</code> (default) when the node is optimistic, and false if it has been fully validated.</p><p>The <code>protoarray.Node</code> structure instead has to keep track of invalid nodes as well:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> Node </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">struct</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    slot                     types</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">Slot                   </span><span class="token comment" style="color:rgb(98, 114, 164)">// slot of the block converted to the node.</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><span class="token operator">...</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    status                   status                       </span><span class="token comment" style="color:rgb(98, 114, 164)">// optimistic status of this node</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token comment" style="color:rgb(98, 114, 164)">// enum used as optimistic status of a node</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">type</span><span class="token plain"> status </span><span class="token builtin" style="color:rgb(189, 147, 249)">uint8</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">const</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    syncing status </span><span class="token operator">=</span><span class="token plain"> </span><span class="token boolean">iota</span><span class="token plain"> </span><span class="token comment" style="color:rgb(98, 114, 164)">// the node is optimistic</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    valid                 </span><span class="token comment" style="color:rgb(98, 114, 164)">//fully validated node</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">    invalid               </span><span class="token comment" style="color:rgb(98, 114, 164)">// invalid execution payload</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><mark>Besides tracking their optimistic status, an optimistic forkchoice node does not have any difference with fully validated nodes. They count for justification/finalization and head computations just like a fully validated node.</mark><p>Finally, forkchoice returns the optimistic status of a blockroot via the exposed self-described function:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">    </span><span class="token function" style="color:rgb(80, 250, 123)">IsOptimistic</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">root </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token number">32</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token builtin" style="color:rgb(189, 147, 249)">byte</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token builtin" style="color:rgb(189, 147, 249)">bool</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(189, 147, 249)">error</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="blockchain-package"></a>Blockchain package<a class="hash-link" href="#blockchain-package" title="Direct link to heading">#</a></h3><p>We have already described at a high level the changes in the blockchain package in the previous section. The main function during block processing in regular sync is the function <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block.go#L96" target="_blank" rel="noopener noreferrer">onBlock</a>. This function executes the state transition and calls the execution engine via <code>notifyNewPayload</code>.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="321-notifynewpayload"></a>3.2.1 <code>notifyNewPayload</code><a class="hash-link" href="#321-notifynewpayload" title="Direct link to heading">#</a></h4><p> Since the block hasn&#x27;t been inserted to forkchoice yet, it records the return of this function. Recall that a block is inserted optimistically to forkchoice by default. If <code>notifyNewPayload</code> has returned VALID, then we call <code>SetOptimiticToValid</code> right after inserting the block to forkchoice.</p><p>The return type of <code>notifyNewPayload</code> is</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">func</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">s </span><span class="token operator">*</span><span class="token plain">Service</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">notifyNewPayload</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token operator">...</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token builtin" style="color:rgb(189, 147, 249)">bool</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> </span><span class="token builtin" style="color:rgb(189, 147, 249)">error</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>it returns <code>true</code> when the payload has been fully validated and is VALID. It returns <code>false, nil</code> when the payload has not been fully validated and the block can be optimistically synced (that is, the engine has returned ACCEPTED / SYNCING and the block passes the checks in section <a href="#21-which-blocks-can-be-imported-optimistically">2.1</a>.</p><p>The function returns an error if either the block was deemed INVALID or an unhandled execution engine error was returned.</p><p>If the return from the execution engine is INVALID, within <code>notifyNewPayload</code> we call the blockchain function <code>SetOptimisticToInvalid</code> described above, to obtain the list of blockroots that have been previously imported optimistically and we now know were in fact INVALID. These blocks, and their corresponding state summaries and states have been imported to our database. We call <a href="https://github.com/zeroone-boa/agora-cl/blob/0ed5007d2e51874f158d4bc8dbd632b1b547b3d7/beacon-chain/blockchain/execution_engine.go#L305" target="_blank" rel="noopener noreferrer">removeInvalidBlockAndState</a> from the <code>blockchain</code> package. This function simply takes the list of invalid roots and removes the corresponding blocks from the database and the states from the state cache.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="322-notifyforkchoiceupdate"></a>3.2.2 <code>notifyForkchoiceUpdate</code><a class="hash-link" href="#322-notifyforkchoiceupdate" title="Direct link to heading">#</a></h4><p>The other situation where we have to deal with optimistic status during <code>onBlock</code> is when we call <code>notifyForkchoiceUpdate</code>, this function is called from <code>onBlock</code> by calling first <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/receive_attestation.go#L174" target="_blank" rel="noopener noreferrer">notifyEngineIfChangedHead</a>.</p><p><code>notifyForkchoiceUpdate</code> has a more complicated logic in regard to optimistic status. If the response from the ELC is VALID, then it informs forkchoice via <code>SetOptimisticToValid</code> (recall the block has been already inserted to forkchoice if its to become head). If it is SYNCING then it returns without doing anything. The reason for this is that the default for a forkchoice node is to be optimistic, and a transition VALID -&gt; SYNCING would be a bug in the ELC.</p><p>The complicated case is when the result is INVALID. In this case the function <code>notifyForkchoiceUpdate</code> will call <code>SetOptimisticToInvalid</code> on the INVALID root, then  prune the blocks with <code>removeInvalidBlocksAndState</code> with the resulting blockroots. Finally it needs to obtain the new Head from forkchoice and call <code>notifyForkchoiceUpdate</code> again, and this process is recursive since we may reorg into another branch that was itself optimistic and containing INVALID blocks again. This procedure will remove all INVALID branches from the forkchoice tree and then return with an error marking the last imported block as invalid.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="323-attestation-processing"></a>3.2.3 Attestation processing<a class="hash-link" href="#323-attestation-processing" title="Direct link to heading">#</a></h4><p>Another path that triggers a call to <code>notifyForkchoiceUpdate</code>, although not strictly speaking involved with optimistic sync is when processing attestation. Agora-cl runs the following on every slot with a time ticker:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token plain">st </span><span class="token operator">:=</span><span class="token plain"> slots</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">NewSlotTicker</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">genesisTime</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> params</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">BeaconConfig</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">SecondsPerSlot</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">for</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">select</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">case</span><span class="token plain"> </span><span class="token operator">&lt;-</span><span class="token plain">s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ctx</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">Done</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                        </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">case</span><span class="token plain"> </span><span class="token operator">&lt;-</span><span class="token plain">st</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">C</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">:</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                        </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">if</span><span class="token plain"> err </span><span class="token operator">:=</span><span class="token plain"> s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">ForkChoicer</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">NewSlot</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ctx</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">CurrentSlot</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> err </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token boolean">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">WithError</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">err</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">Error</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;Could not process new slot&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                        </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                        </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">if</span><span class="token plain"> err </span><span class="token operator">:=</span><span class="token plain"> s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">UpdateHead</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">s</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token plain">ctx</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> err </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token boolean">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                log</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">WithError</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">err</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">Error</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;Could not process attestations and update head&quot;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                                </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                        </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">                </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>It is important to keep this path in mind when considering forkchoice changes, the function <code>NewSlot</code> updates the justification and finalization of forkchoice when called at the beginning of an epoch. The function <code>UpdateHead</code> will process attestations and then update head if necessary, calling <code>notifyForkchoiceUpdate</code> in the process if the head as been updated due to new attestations.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="324-init-sync"></a>3.2.4 Init sync<a class="hash-link" href="#324-init-sync" title="Direct link to heading">#</a></h4><p>The path for init sync is very similar to sections <a href="#321-notifynewpayload">3.2.1</a> and <a href="#322-notifyforkchoiceupdate">3.2.2</a>. The main block processing function during init sync is the function <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block.go#L282" target="_blank" rel="noopener noreferrer">onBlockBatch</a>. This function does essentially the same processing as <code>onBlock</code> but it takes consecutive batches of blocks to do signature verification by aggregation. In what regards to optimistic syncing the behavior is the same as in regular sync: for each block a call to  <code>notifyNewPayload</code> is made. However only after the full batch has been processed and verified, it is inserted in forkchoice. Only the last block inserted is considered for optimistic sync, namely if this block is VALID, then the whole batch is considered VALID, otherwise the whole batch is considered optimistic. Since the batch is linear, we only call <code>notifyForkchoiceUpdate</code> in the last block of the batch.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="33-grpc-api"></a>3.3 (g)RPC API<a class="hash-link" href="#33-grpc-api" title="Direct link to heading">#</a></h3><p>A CLC is required to respond to requests for blocks, state information, head information, etc. The node is required to provide optimistic status information in its reply. Many of the endpoints simply add a JSON field <code>is_optimistic</code> that results <code>true</code> when the corresponding block has been inserted optimistically or <code>false</code> when it has been fully validated. The Agora node ultimately calls the two functions <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/chain_info.go#L301" target="_blank" rel="noopener noreferrer">IsOptimistic</a> and <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/chain_info.go#L322" target="_blank" rel="noopener noreferrer">IsOptimisticForRoot</a>.</p><p>The former is just a wrapper around the latter, it fetches the head root of the node and calls the latter. The latter returns whether the block with the given root is optimistic. It does so by calling first forkchoice&#x27;s <code>IsOptimistic</code> and if it fails it checks with the database as explained in the next section.</p><p>Perhaps the most important impact that optmistic sync has on the API section, is that when the validator calls <code>GetBlock</code> to obtain a new block to propose, or when it calls <code>GetAttestationData</code> to obtain an attestation and so forth, for each of the validator duties, the corresponding RPC calls include a call to check the optimistic status of the node as follows:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly go"><pre tabindex="0" class="prism-code language-go codeBlock_23N8 thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#F8F8F2"><span class="token comment" style="color:rgb(98, 114, 164)">// An optimistic validator MUST NOT participate in attestation. (i.e., sign across the DOMAIN_BEACON_ATTESTER, DOMAIN_SELECTION_PROOF or DOMAIN_AGGREGATE_AND_PROOF domains).</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">if</span><span class="token plain"> err </span><span class="token operator">:=</span><span class="token plain"> vs</span><span class="token punctuation" style="color:rgb(248, 248, 242)">.</span><span class="token function" style="color:rgb(80, 250, 123)">optimisticStatus</span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">ctx</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token punctuation" style="color:rgb(248, 248, 242)">;</span><span class="token plain"> err </span><span class="token operator">!=</span><span class="token plain"> </span><span class="token boolean">nil</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">      </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">return</span><span class="token plain"> </span><span class="token boolean">nil</span><span class="token punctuation" style="color:rgb(248, 248, 242)">,</span><span class="token plain"> err</span></span><span class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>It is important, and dangerous to not act in optimistic node. From a network perspective because it may lead to finalization/justification of an invalid chain. And from a selfish perspective because it may lead to slashing eventually when we slash validators for attesting on invalid payloads.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="34-database"></a>3.4 Database<a class="hash-link" href="#34-database" title="Direct link to heading">#</a></h3><p>We have described in section <a href="#31-forkchoice-package">3.1</a> that the forkchoice package is responsible for tracking the optimistic status of imported nodes. Forkchoice however prunes nodes after finalization and we can finalize during optimistic mode. If we require optimistic information about an ancient block we request this information from the database. The database tracks the last <em>validated checkpoint</em>. This is a checkpoint by which any canonical block older than it is considered VALID, and any block that is not in forkchoice and that is newer than the last validated checkpoint, is optimistic. The function to obtain this information is <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/db/kv/validated_checkpoint.go#L13" target="_blank" rel="noopener noreferrer">LastValidatedCheckpoint</a>.</p><p>Notice that any orphaned block in the database, even those older than the last validated checkpoint, will be served as  optimistic, even though they may have been fully validated. This is a compromise to avoid complicated setups as we <a href="https://www.notion.so/Bosagora/Optimistic-blocks-storage-05d0832243ce46b4bd36e422e8f8e15f#85e6baf047eb4d16b9d0fc2ca6ad8569" target="_blank" rel="noopener noreferrer">previously had designed</a>.</p><p>The last validated checkpoint is updated only when we finalize a new checkpoint and thus its pruned from forkchoice. The corresponding function is <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/db/kv/validated_checkpoint.go#L32" target="_blank" rel="noopener noreferrer">SaveLastValidatedCheckpoint</a> and is called from <a href="https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block_helpers.go#L139" target="_blank" rel="noopener noreferrer">updateFinalized</a>. This latter function is called both from <code>onBlock</code> and <code>onBlockBatch</code> when processing a block in regular or init sync that updates finalization.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-some-edge-cases-and-unsolved-problems"></a>4 Some edge cases and unsolved problems<a class="hash-link" href="#4-some-edge-cases-and-unsolved-problems" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="41-justification-reversal-after-pruning"></a>4.1 Justification reversal after pruning<a class="hash-link" href="#41-justification-reversal-after-pruning" title="Direct link to heading">#</a></h3><p>Most of the edge cases with optimistic sync happen in the presence of invalid payload. We have already described the situation with <a href="#forkchoice-poisoning">Forkchoice Poisoning</a>. The following similar situations have been described in the open issues <a href="https://github.com/zeroone-boa/agora-cl/issues/10782" target="_blank" rel="noopener noreferrer">10782</a> and <a href="https://github.com/zeroone-boa/agora-cl/issues/107770" target="_blank" rel="noopener noreferrer">10777</a>. They are variations of the same phenomenon: an INVALID chain is imported and it updates justification, even though the justification checkpoint is VALID, the node may be deadlocked.</p><p>Consider the following diagram:</p><p><img src="https://i.imgur.com/N3b9LMM.jpg"></p><p>At the beginning of Epoch 10 the justified epoch is 9, the justified checkpoint is pointed by block <code>A</code>. The epoch advances fine but the ELC is still syncing, therefore this node is taking blocks optimistically. Block <code>C</code>  in epoch 10 may have or may not have enough attestations to justify Epoch 10, but its own post-state justification checkpoint is still block <code>A</code> in Epoch 9, as justification is updated only on epoch processing.  Block <code>D</code> is the first block imported in epoch 11 and it is the first one to justify block B in epoch 10. At this point the forkchoice store&#x27;s justification checkpoint updates to block <code>B</code> in epoch 10. The chain advances and when importing the block <code>E</code> the ELC has fully synced and returns INVALID, with a LVH pointing to the fork block <code>X</code>. We call forkchoice&#x27;s <code>SetOptimisticToInvalid</code> and remove all invalid blocks in the chain <code>D</code>--<code> E</code> . How should we update Head? the block <code>C</code> is not eligible for head since its justification point is <code>A</code> with Epoch 9 and the store&#x27;s justification is <code>B</code> with Epoch 10. At this point the node is deadlocked. It cannot import any block unless the very next block that is imported realizes the justification at Epoch 10. If it doesn&#x27;t it will fail in the same way, by not being eligible for Head, and therefore that node (and possibly all the honest chain built on it) will never be imported.</p><p>Notice that this may happen during optimistic syncing of the merge block, precisely in the situation that the <a href="#forkchoice-poisoning">forkchoice poisoning</a> attack described. In this case, even with the prevision of <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code>, we would be deadlocked.</p><p>We could revert justification, but this becomes very hard to implement and standardize across clients since we do not keep track of when the justification has changed. What Teku does is allow head to be the last justified checkpoint, in this case it would be <code>B</code>. But that would make the node behave as it would be non-optimistic and lead to problems if a big part of the network is in optimistic mode. An option we are considering is to make the node be optimistic if the head is optimistic or if the head is the justified checkpoint, as the justified checkpoint can never be head except when it is the genesis checkpoint or the first slot when we are using checkpoint sync.</p><p>This problem was found independently by many and there are different ad-hoc implementations to fix them, but clients currently diverge in their behavior at this point.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="42-timeouts-and-unhandled-errors"></a>4.2 Timeouts and unhandled errors<a class="hash-link" href="#42-timeouts-and-unhandled-errors" title="Direct link to heading">#</a></h3><p>Another common themes for bugs with optimistic sync is the handling of timeouts and unhandled errors from the ELC. When the ELC timesout on a call to <code>notifyNewPayload</code>, it has not replied neither saying that it has fully validated the block nor that it is SYNCING. Ironically, this means that a node that was previously lock-stepping is not to be considered optimistic and can actually attest to its previous head, and propose a block based on its previous head. We are not allowed however to import a block which the ELC has not returned of of VALID, INVALID, ACCEPTED or SYNCING. The following situation has happened in a couple of merged networks and shadow forks: the ELC timesout the CLC does not send any new payload since it can&#x27;t import any block. The CLC should consider resending either <code>notifyNewPayload</code>  or <code>notifyForkchoiceUpdate</code> to the ELC if it has timedout and the CLC is not importing a new block because of this.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/zeroone-boa/agora-cl-docs/edit/master/website/docs/how-agora-cl-works/optimistic-sync.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/how-agora-cl-works/validator-lifecycle"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Validator lifecycle</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/how-agora-cl-works/validator-deposit-contract"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Validator deposit contract Â»</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-what-is-optimistic-sync" class="table-of-contents__link">1 What is optimistic sync?</a><ul><li><a href="#the-happy-case" class="table-of-contents__link">The happy case</a></li></ul></li><li><a href="#2-specification" class="table-of-contents__link">2 Specification</a><ul><li><a href="#21-which-blocks-can-be-imported-optimistically" class="table-of-contents__link">2.1 Which blocks can be imported optimistically?</a></li><li><a href="#22-the-engine-api" class="table-of-contents__link">2.2 The engine API</a></li><li><a href="#23-optimistic-node" class="table-of-contents__link">2.3 Optimistic Node</a></li><li><a href="#24-forkchoice-poisoning" class="table-of-contents__link">2.4 Forkchoice Poisoning</a></li></ul></li><li><a href="#3-implementation-in-agora-cl" class="table-of-contents__link">3 Implementation in Agora-cl</a><ul><li><a href="#31-forkchoice-package" class="table-of-contents__link">3.1 Forkchoice package</a></li><li><a href="#blockchain-package" class="table-of-contents__link">Blockchain package</a></li><li><a href="#33-grpc-api" class="table-of-contents__link">3.3 (g)RPC API</a></li><li><a href="#34-database" class="table-of-contents__link">3.4 Database</a></li></ul></li><li><a href="#4-some-edge-cases-and-unsolved-problems" class="table-of-contents__link">4 Some edge cases and unsolved problems</a><ul><li><a href="#41-justification-reversal-after-pruning" class="table-of-contents__link">4.1 Justification reversal after pruning</a></li><li><a href="#42-timeouts-and-unhandled-errors" class="table-of-contents__link">4.2 Timeouts and unhandled errors</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a class="footerLogoLink_MyFc" href="/docs/getting-started"><img src="/img/Agora-cl.svg" alt="Agora-cl Docs" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="/img/Agora-cl.svg" alt="Agora-cl Docs" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></a></div><div class="footer__copyright">Copyright Â© 2022 Bosagora, Validator Deposit Contract 0xXXX</div></div></div></footer></div>
<script src="/assets/js/runtime~main.bf2263fc.js"></script>
<script src="/assets/js/main.a87cd8b8.js"></script>
</body>
</html>