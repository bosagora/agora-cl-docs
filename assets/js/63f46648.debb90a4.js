"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4694],{3905:(e,t,i)=>{i.d(t,{Zo:()=>h,kt:()=>m});var n=i(7294);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?a(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):a(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function r(e,t){if(null==e)return{};var i,n,o=function(e,t){if(null==e)return{};var i,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(o[i]=e[i]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var i=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=c(i),m=o,u=d["".concat(l,".").concat(m)]||d[m]||p[m]||a;return i?n.createElement(u,s(s({ref:t},h),{},{components:i})):n.createElement(u,s({ref:t},h))}));function m(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=i.length,s=new Array(a);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<a;c++)s[c]=i[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,i)}d.displayName="MDXCreateElement"},1262:(e,t,i)=>{i.d(t,{Z:()=>a});var n=i(7294),o=i(2263);const a=function(e){var t=e.children,i=e.fallback;return(0,o.Z)().isClient&&null!=t?n.createElement(n.Fragment,null,t()):i||null}},1144:(e,t,i)=>{i.d(t,{M:()=>a});var n=i(7294),o=i(1262),a=function(e){return function(e){if(null==e)throw new TypeError("Cannot destructure undefined")}(e),n.createElement(o.Z,null,(function(){return n.createElement("div",{class:"update-request"},n.createElement("a",{href:"https://https://github.com/zeroone-boa/agora-cl-docs/issues/new?title=Docs update request: "+new URL(window.location.href).pathname+"&body=Source: "+window.location.href+"%0A%0ARequest: (how can we help?)"},"\ud83d\udc3c Request an update"))}))}},4600:(e,t,i)=>{i.r(t),i.d(t,{contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>h,toc:()=>p});var n=i(7462),o=i(3366),a=(i(7294),i(3905)),s=i(1144),r=["components"],l={id:"optimistic-sync",title:"Optimistic sync",sidebar_label:"Optimistic sync"},c=void 0,h={unversionedId:"how-agora-cl-works/optimistic-sync",id:"how-agora-cl-works/optimistic-sync",isDocsHomePage:!1,title:"Optimistic sync",description:"This content was previously published on HackMD. The version you're reading now is the version that we're maintaining.",source:"@site/docs/how-agora-cl-works/optimistic-sync.md",sourceDirName:"how-agora-cl-works",slug:"/how-agora-cl-works/optimistic-sync",permalink:"/docs/how-agora-cl-works/optimistic-sync",editUrl:"https://github.com/zeroone-boa/agora-cl-docs/edit/master/website/docs/how-agora-cl-works/optimistic-sync.md",version:"current",frontMatter:{id:"optimistic-sync",title:"Optimistic sync",sidebar_label:"Optimistic sync"},sidebar:"docs",previous:{title:"Validator lifecycle",permalink:"/docs/how-agora-cl-works/validator-lifecycle"},next:{title:"Validator deposit contract",permalink:"/docs/how-agora-cl-works/validator-deposit-contract"}},p=[{value:"1 What is optimistic sync?",id:"1-what-is-optimistic-sync",children:[{value:"The happy case",id:"the-happy-case",children:[]}]},{value:"2 Specification",id:"2-specification",children:[{value:"2.1 Which blocks can be imported optimistically?",id:"21-which-blocks-can-be-imported-optimistically",children:[]},{value:"2.2 The engine API",id:"22-the-engine-api",children:[]},{value:"2.3 Optimistic Node",id:"23-optimistic-node",children:[]},{value:"2.4 Forkchoice Poisoning",id:"24-forkchoice-poisoning",children:[]}]},{value:"3 Implementation in Agora-cl",id:"3-implementation-in-agora-cl",children:[{value:"3.1 Forkchoice package",id:"31-forkchoice-package",children:[]},{value:"Blockchain package",id:"blockchain-package",children:[]},{value:"3.3 (g)RPC API",id:"33-grpc-api",children:[]},{value:"3.4 Database",id:"34-database",children:[]}]},{value:"4 Some edge cases and unsolved problems",id:"4-some-edge-cases-and-unsolved-problems",children:[{value:"4.1 Justification reversal after pruning",id:"41-justification-reversal-after-pruning",children:[]},{value:"4.2 Timeouts and unhandled errors",id:"42-timeouts-and-unhandled-errors",children:[]}]}],d={toc:p};function m(e){var t=e.components,i=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"This content was previously ",(0,a.kt)("a",{parentName:"p",href:"https://hackmd.io/5NhsX8FvSm2GqESpdpe-Vg?view"},"published on HackMD"),". The version you're reading now is the version that we're maintaining."))),(0,a.kt)("p",null,"In this document we cover optimistic sync and its detailed implementation in Agora-cl. We explain the numerous subtle edge cases that arise because of it and the mitigation factors to some attacks that arise when several nodes are optimistic. We start with a high level introduction to what optimistic sync is and how it is specified, and then move to the specific details within Agora-cl's implementation."),(0,a.kt)("p",null,"We describe Agora-cl's API to deal with optimistic sync, describing what the involved functions do, but not ",(0,a.kt)("strong",{parentName:"p"},"how they do it"),". For example, we describe that ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/forkchoice/doubly-linked-tree/optimistic_sync.go#L10"},"SetOptimisticToInvalid")," prunes invalid nodes from the forkchoice tree, but do not explain how this pruning is achieved."),(0,a.kt)("h2",{id:"1-what-is-optimistic-sync"},"1 What is optimistic sync?"),(0,a.kt)("p",null,"Simply put, optimistic sync allows a consensus layer client (CLC) to import, process, and consider a beacon block for its forkchoice head, even though it has not validated its execution payload. Thus, syncing this block ",(0,a.kt)("em",{parentName:"p"},"optimistically")," hoping that the block will be eventually validated by the execution layer client (ELC)."),(0,a.kt)("p",null,"Optimistic sync was devised because of the different mechanisms utilized by the CLC and the ELC to sync. Most ELC use a syncing mechanism called ",(0,a.kt)("em",{parentName:"p"},"snap sync")," by which they download a snapshot of the current state from their P2P network, and then proceed to download backwards the blocks and transactions filling its history. Since after the merge, the CLC drives the ELC, without a mechanism to allow the execution layer to sync independently from the consensus layer, it would never catch up to head. The most obvious alternative, known as ",(0,a.kt)("em",{parentName:"p"},"lockstep syncing")," consists of starting with a synced state, and importing one block at a time, importing first from the consensus layer and passing down the execution payload to the execution layer. Current sync block times show that syncing a small network like Kiln would take over a couple of weeks in lockstep mode on a decent server. There is a more sensible alternative to optimistic sync using the ",(0,a.kt)("em",{parentName:"p"},"Light client protocol")," which we will not cover in this document."),(0,a.kt)("h3",{id:"the-happy-case"},"The happy case"),(0,a.kt)("p",null,"From the user's perspective, the overwhelming majority of nodes that are  optimistically syncing are nodes that have just been started. The CLC can use checkpoint sync and be in sync in under 2 minutes. Snapshot sync for the ELC on the other hand will take much longer. Until the ELC catches up on head, the CLC may continue to import and keep syncing the beaconchain in optimistic mode. There are few edge cases in this situation. All edge cases and subtle considerations happen when an otherwise synced node, falls into optimistic sync due to an unforeseen circumstance."),(0,a.kt)("h2",{id:"2-specification"},"2 Specification"),(0,a.kt)("h3",{id:"21-which-blocks-can-be-imported-optimistically"},"2.1 Which blocks can be imported optimistically?"),(0,a.kt)("p",null,"The specification of optimistic sync is fairly simple. A node makes the following validations on a beacon block to decide if it can be imported or not into its forkchoice/database. If the block fails consensus validation (signature, operations, right proposer, etc, but excluding execution payload validation), then reject the block and do not import it. Assuming that we have a beacon block that passes this validation. The following blocks are allowed to be imported:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the block is pre-merge (ie. it does not include an execution payload)."),(0,a.kt)("li",{parentName:"ul"},"If the parent of the block is post-merge (ie. it does include an execution payload).")),(0,a.kt)("p",null,"This leaves only a merge block itself unaccounted for, that is a block which does include an execution payload, but it is the ",(0,a.kt)("strong",{parentName:"p"},"first")," block in the chain to do so. In this case an extra rule is applied:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If the block's slot is old enough, it is allowed to be imported. Here ",(0,a.kt)("em",{parentName:"li"},"old enough")," means that the block slot is lower than the current wall time slot by at least ",(0,a.kt)("inlineCode",{parentName:"li"},"SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY")," which in the current spec defaults to 128 slots.")),(0,a.kt)("p",null,"This last rule, which is the only rule from the consensus layer side preventing a node from importing a block, is to mitigate an attack known as the ",(0,a.kt)("em",{parentName:"p"},"forkchoice poisoning attack")," which we will cover below in section ",(0,a.kt)("a",{parentName:"p",href:"#24-forkchoice-poisoning"},"2.4"),"."),(0,a.kt)("h3",{id:"22-the-engine-api"},"2.2 The engine API"),(0,a.kt)("p",null,"When the CLC receives a block with an embedded execution payload, it notifies the ELC via two different engine API RPC calls: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_newpayloadv1"},"engine_newPayloadv1")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#engine_forkchoiceupdatedv1"},"engine_forkchoiceUpdateV1"),". These are wrapped internally within Agora-cl in the blockchain's package methods ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/execution_engine.go#L160"},"notifyNewPayload")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/execution_engine.go#L36"},"notifyForkchoiceUpdate"),". These functions are used in different stages of block processing and have different semantics for the ELC. We call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," to inform the ELC that this payload is available and request its validation. We call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoceUpdate")," to inform the ELC that our head has changed and that it should react accordingly (changing the current execution state, the list of canonical blocks, etc)."),(0,a.kt)("p",null,"When Agora-cl receives a block, after the pubsub validation, and assuming regular sync, it enters the blockchain package via the function ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/receive_block.go#L38"},"ReceiveBlock")," and eventually ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block.go#L96"},"onBlock")," is called. At this stage, the consensus aspects of this block have been verified. We call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," and await the return of the ELC. There are five possible outcomes of this call:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"VALID"),(0,a.kt)("li",{parentName:"ol"},"INVALID"),(0,a.kt)("li",{parentName:"ol"},"ACCEPTED/SYNCING"),(0,a.kt)("li",{parentName:"ol"},"Timeout (the ELC has not replied)"),(0,a.kt)("li",{parentName:"ol"},"Error (something went wrong in the call)")),(0,a.kt)("p",null,"Dealing with each one of them requires a different set of careful considerations, roughly ordered by level of difficulty. When we receive ",(0,a.kt)("inlineCode",{parentName:"p"},"VALID")," as a reply, we can simply import the block, this block is not optimistic as it has been fully validated."),(0,a.kt)("p",null,"When we receive ",(0,a.kt)("inlineCode",{parentName:"p"},"INVALID")," a series of checks need to be carried out, we will go over them in the following sections of this document. It suffices to say that for a non-optimistic node (ie. a node that has been syncing in lockstep) when it receives an ",(0,a.kt)("inlineCode",{parentName:"p"},"INVALID")," response from this call, its processing is very simple: we just do not import this block, it has failed validation, we mark the block as invalid and ",(0,a.kt)("inlineCode",{parentName:"p"},"onBlock")," (and subsequently ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/receive_block.go#L380"},"ReceiveBlock"),") will return with an error, without affecting core logic. What triggers optimistic sync is the response in 3) ACCEPTED/SYNCING. Both replies are treated in the exact same way by Agora-cl, but it is useful to understand the different semantics from the point of view of the ELC. Suppose we are following a chain that is following like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://i.imgur.com/wMobZC2.png",alt:null})),(0,a.kt)("p",null,"Our head is ",(0,a.kt)("inlineCode",{parentName:"p"},"D"),", and the ELC has returned ",(0,a.kt)("inlineCode",{parentName:"p"},"VALID"),"  for it when we called\n",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdated"),"  to inform that our head had changed to ",(0,a.kt)("inlineCode",{parentName:"p"},"D"),". We now receive a block in a side chain, orphaning ",(0,a.kt)("inlineCode",{parentName:"p"},"D")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"C"),":"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://i.imgur.com/sYz9uRQ.png",alt:null})),(0,a.kt)("p",null,"Regardless of what happened to our forkchoice, as we first call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload"),"  before making any head considerations, our head will still be ",(0,a.kt)("inlineCode",{parentName:"p"},"D"),"  at the moment of calling ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload"),". Different ELC will return different replies here. They are not required to execute and validate the block ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," as it does not extend their canonical chain. Some will do anyway, and thus can return VALID / INVALID if they executed the payload completely. Others will simply check that the timestamps, parent block hash and similar header numbers are consistent and will return ACCEPTED, indicating that the block ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is ready to be executed but hasn't been fully validated yet. Another option is if the ELC does not have the execution payload of the block ",(0,a.kt)("inlineCode",{parentName:"p"},"E"),"  for some reason. In this case the ELC will return SYNCING and it may or may not trigger a request for this block. Either way, a reply of ACCEPTED or SYNCING means that there is nothing evidently wrong with the block, that we may go ahead and import it optimistically, and we will eventually validate it if it is necessary."),(0,a.kt)("p",null,"If the block ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," is therefore ACCEPTED or SYNCING, we will run the checks in section ",(0,a.kt)("a",{parentName:"p",href:"#21-which-blocks-can-be-imported-optimistically"},"2.1")," and import it if it satisfies those conditions."),(0,a.kt)("h3",{id:"23-optimistic-node"},"2.3 Optimistic Node"),(0,a.kt)("p",null,"It may happen that after importing this block ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," it becomes head. In this case we will inform the ELC by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdated"),". The engine is now ",(0,a.kt)("strong",{parentName:"p"},"required")," to execute and validate block ",(0,a.kt)("inlineCode",{parentName:"p"},"F")," if it hasn't done so already. Some engines (eg geth) would have already validated the block if the fork was not long enough. In this case they will return immediately VALID / INVALID. Other engines may not have executed it, specifically, if they haven't executed even block ",(0,a.kt)("inlineCode",{parentName:"p"},"E"),", or if they do not even have block ",(0,a.kt)("inlineCode",{parentName:"p"},"E"),", they will return SYNCING. In this case, the CLC has already imported the block ",(0,a.kt)("inlineCode",{parentName:"p"},"F"),", which is now its current head, and it has been imported optimistically. When this happens we say that ",(0,a.kt)("strong",{parentName:"p"},"the node is optimistic"),"."),(0,a.kt)("mark",null,"An optimistic node may not act on its head: it cannot propose a block, it cannot attest to an optimistic head and cannot sign sync committee duties.")," It may (and should) however gossip optimistic blocks.",(0,a.kt)("h3",{id:"24-forkchoice-poisoning"},"2.4 Forkchoice Poisoning"),(0,a.kt)("p",null,"We mentioned above a subtle condition preventing a node from optimistically syncing the merge block. This attack happens as follows. Suppose we have a forkchoice situation like the following diagram:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://i.imgur.com/DVcZili.jpg",alt:null})),(0,a.kt)("p",null,"An attacker is able to propose a block ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," which satisfies:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It is the merge block"),(0,a.kt)("li",{parentName:"ul"},"It's parent execution block is invalid or non-existent"),(0,a.kt)("li",{parentName:"ul"},"It justifies a new checkpoint in the beacon-chain")),(0,a.kt)("p",null,"A node that is optimistically syncing the Agora chain in this conditions will not be able to follow any other chain until the network justifies a higher checkpoint. The reason is the way we decide our head in the forkchoice package: we choose among the tips of the forkchoice tree, those that have the higher justification first. For more details on this procedure you can look at the slides in ",(0,a.kt)("a",{parentName:"p",href:"https://drive.google.com/file/d/1aiUIVjPEGUv9iNESHaSfFN4DfLgba8al/view?usp=sharing"},"this video"),".  Any other block imported in a separate branch will not be considered for head unless it also justifies a higher point. An honest validator following this invalid chain will not be able to leave optimistic mode unless the chain justifies a higher point: it can't fully sync since the ELC cannot find the parent of the merge block, and it can't jump head because it can't choose a lower justification point."),(0,a.kt)("p",null,"With the assumption that the majority of the chain will justify a checkpoint after the merge in less than ",(0,a.kt)("inlineCode",{parentName:"p"},"SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY"),", then it is safe to import optimistically the merge block, knowing that at least this many slots have passed and we will have an honest justified checkpoint available to jump, in case this merge block is not valid."),(0,a.kt)("h2",{id:"3-implementation-in-agora-cl"},"3 Implementation in Agora-cl"),(0,a.kt)("p",null,"Agora-cl's implementation of optimistic sync involves several different packages. It principally touches the forkchoice and blockchain packages as it changes the core handling of beacon blocks. But it also touches the database (package kv) and the sync package (during init sync and pubsub validation) and the RPC endpoints.  In this section we will cover all the paths added in each package."),(0,a.kt)("h3",{id:"31-forkchoice-package"},"3.1 Forkchoice package"),(0,a.kt)("p",null,"The forkchoice package keeps track of the optimistic status of each node. This is required as an optimistic node cannot perform its duties. When inserting a node, it is by default considered optimistic. Its status can be changed to fully validated with the function ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/forkchoice/doubly-linked-tree/forkchoice.go#L378"},"SetOptimisticToValid"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func (f *ForkChoice) SetOptimisticToValid(ctx context.Context, root [fieldparams.RootLength]byte) error\n")),(0,a.kt)("p",null,"This function simply takes the HTR of the block and it sets its optimistic status to VALID. It also sets the optimistic status of any ancestor to VALID since a block cannot be fully validated if its ancestors weren't."),(0,a.kt)("p",null,"If a block that was imported optimistically later becomes INVALID, this can be notified with the function ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/forkchoice/doubly-linked-tree/optimistic_sync.go#L10"},"SetOptimisticToInvalid"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func (s *Store) setOptimisticToInvalid(ctx context.Context, root, parentRoot, payloadHash [32]byte) ([][32]byte, error)\n")),(0,a.kt)("p",null,"The reader will notice that the signature of this function is different. The reason is that when the ELC returns INVALID from ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," , it also returns the latest valid hash (LVH), that is, the payload hash of the unique execution block that satisfies the following two conditions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It is a VALID ancestor of the INVALID payload"),(0,a.kt)("li",{parentName:"ul"},"Any ancestor of the INVALID payload, with a higher ",(0,a.kt)("inlineCode",{parentName:"li"},"blockNumber"),", is INVALID")),(0,a.kt)("p",null,"The INVALID payload itself may or may not be in the forkchoice store, in fact, it will ",(0,a.kt)("strong",{parentName:"p"},"almost never")," be, since we only call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," with new blocks before we insert them to forkchoice. The function ",(0,a.kt)("inlineCode",{parentName:"p"},"setOptimisticToInvalid")," takes as parameters the root of the INVALID block, the root of its parent block, and the LVH. It works by first finding the unique block satisfying the following conditions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It is a child of the LVH"),(0,a.kt)("li",{parentName:"ul"},"It is an ancestor of the INVALID payload")),(0,a.kt)("p",null,"And then it removes that block and ",(0,a.kt)("strong",{parentName:"p"},"every descentant")," of it. This is strictly true in the ",(0,a.kt)("inlineCode",{parentName:"p"},"doubly-linked-tree"),"  implementation of forkchoice. But this is not the case in the ",(0,a.kt)("inlineCode",{parentName:"p"},"protoarray")," implementation. Removing nodes from the ",(0,a.kt)("inlineCode",{parentName:"p"},"protoarray")," implementation is complicated. Thus what we do in this case is mark the nodes as INVALID instead. After removal of the nodes, the weights of the remaining forkchoice tree needs to be readjusted. The function returns the blockroots of all the removed nodes (or those nodes marked as invalid in the ",(0,a.kt)("inlineCode",{parentName:"p"},"protoarray")," implementation)."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"doublylinkedtree.Node")," structure has a boolean ",(0,a.kt)("inlineCode",{parentName:"p"},"optimistic"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type Node struct {\n    slot                     types.Slot                   // slot of the block converted to the node.\n        ...\n    optimistic               bool                         // whether the block has been fully validated or not\n}\n")),(0,a.kt)("p",null,"That is ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," (default) when the node is optimistic, and false if it has been fully validated."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"protoarray.Node")," structure instead has to keep track of invalid nodes as well:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type Node struct {\n    slot                     types.Slot                   // slot of the block converted to the node.\n        ...\n    status                   status                       // optimistic status of this node\n}\n// enum used as optimistic status of a node\ntype status uint8\nconst (\n    syncing status = iota // the node is optimistic\n    valid                 //fully validated node\n    invalid               // invalid execution payload\n)\n")),(0,a.kt)("mark",null,"Besides tracking their optimistic status, an optimistic forkchoice node does not have any difference with fully validated nodes. They count for justification/finalization and head computations just like a fully validated node."),(0,a.kt)("p",null,"Finally, forkchoice returns the optimistic status of a blockroot via the exposed self-described function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"    IsOptimistic(root [32]byte) (bool, error)\n")),(0,a.kt)("h3",{id:"blockchain-package"},"Blockchain package"),(0,a.kt)("p",null,"We have already described at a high level the changes in the blockchain package in the previous section. The main function during block processing in regular sync is the function ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block.go#L96"},"onBlock"),". This function executes the state transition and calls the execution engine via ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload"),"."),(0,a.kt)("h4",{id:"321-notifynewpayload"},"3.2.1 ",(0,a.kt)("inlineCode",{parentName:"h4"},"notifyNewPayload")),(0,a.kt)("p",null," Since the block hasn't been inserted to forkchoice yet, it records the return of this function. Recall that a block is inserted optimistically to forkchoice by default. If ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," has returned VALID, then we call ",(0,a.kt)("inlineCode",{parentName:"p"},"SetOptimiticToValid")," right after inserting the block to forkchoice."),(0,a.kt)("p",null,"The return type of ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," is"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func (s *Service) notifyNewPayload(...) (bool, error)\n")),(0,a.kt)("p",null,"it returns ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," when the payload has been fully validated and is VALID. It returns ",(0,a.kt)("inlineCode",{parentName:"p"},"false, nil")," when the payload has not been fully validated and the block can be optimistically synced (that is, the engine has returned ACCEPTED / SYNCING and the block passes the checks in section ",(0,a.kt)("a",{parentName:"p",href:"#21-which-blocks-can-be-imported-optimistically"},"2.1"),"."),(0,a.kt)("p",null,"The function returns an error if either the block was deemed INVALID or an unhandled execution engine error was returned."),(0,a.kt)("p",null,"If the return from the execution engine is INVALID, within ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," we call the blockchain function ",(0,a.kt)("inlineCode",{parentName:"p"},"SetOptimisticToInvalid")," described above, to obtain the list of blockroots that have been previously imported optimistically and we now know were in fact INVALID. These blocks, and their corresponding state summaries and states have been imported to our database. We call ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/0ed5007d2e51874f158d4bc8dbd632b1b547b3d7/beacon-chain/blockchain/execution_engine.go#L305"},"removeInvalidBlockAndState")," from the ",(0,a.kt)("inlineCode",{parentName:"p"},"blockchain")," package. This function simply takes the list of invalid roots and removes the corresponding blocks from the database and the states from the state cache."),(0,a.kt)("h4",{id:"322-notifyforkchoiceupdate"},"3.2.2 ",(0,a.kt)("inlineCode",{parentName:"h4"},"notifyForkchoiceUpdate")),(0,a.kt)("p",null,"The other situation where we have to deal with optimistic status during ",(0,a.kt)("inlineCode",{parentName:"p"},"onBlock")," is when we call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate"),", this function is called from ",(0,a.kt)("inlineCode",{parentName:"p"},"onBlock")," by calling first ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/receive_attestation.go#L174"},"notifyEngineIfChangedHead"),"."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate")," has a more complicated logic in regard to optimistic status. If the response from the ELC is VALID, then it informs forkchoice via ",(0,a.kt)("inlineCode",{parentName:"p"},"SetOptimisticToValid")," (recall the block has been already inserted to forkchoice if its to become head). If it is SYNCING then it returns without doing anything. The reason for this is that the default for a forkchoice node is to be optimistic, and a transition VALID -> SYNCING would be a bug in the ELC."),(0,a.kt)("p",null,"The complicated case is when the result is INVALID. In this case the function ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate")," will call ",(0,a.kt)("inlineCode",{parentName:"p"},"SetOptimisticToInvalid")," on the INVALID root, then  prune the blocks with ",(0,a.kt)("inlineCode",{parentName:"p"},"removeInvalidBlocksAndState")," with the resulting blockroots. Finally it needs to obtain the new Head from forkchoice and call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate")," again, and this process is recursive since we may reorg into another branch that was itself optimistic and containing INVALID blocks again. This procedure will remove all INVALID branches from the forkchoice tree and then return with an error marking the last imported block as invalid."),(0,a.kt)("h4",{id:"323-attestation-processing"},"3.2.3 Attestation processing"),(0,a.kt)("p",null,"Another path that triggers a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate"),", although not strictly speaking involved with optimistic sync is when processing attestation. Agora-cl runs the following on every slot with a time ticker:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'st := slots.NewSlotTicker(s.genesisTime, params.BeaconConfig().SecondsPerSlot)\n        for {\n                select {\n                case <-s.ctx.Done():\n                        return\n                case <-st.C():\n                        if err := s.ForkChoicer().NewSlot(s.ctx, s.CurrentSlot()); err != nil {\n                                log.WithError(err).Error("Could not process new slot")\n                                return\n                        }\n\n                        if err := s.UpdateHead(s.ctx); err != nil {\n                                log.WithError(err).Error("Could not process attestations and update head")\n                                return\n                        }\n                }\n        }\n')),(0,a.kt)("p",null,"It is important to keep this path in mind when considering forkchoice changes, the function ",(0,a.kt)("inlineCode",{parentName:"p"},"NewSlot")," updates the justification and finalization of forkchoice when called at the beginning of an epoch. The function ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateHead")," will process attestations and then update head if necessary, calling ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate")," in the process if the head as been updated due to new attestations."),(0,a.kt)("h4",{id:"324-init-sync"},"3.2.4 Init sync"),(0,a.kt)("p",null,"The path for init sync is very similar to sections ",(0,a.kt)("a",{parentName:"p",href:"#321-notifynewpayload"},"3.2.1")," and ",(0,a.kt)("a",{parentName:"p",href:"#322-notifyforkchoiceupdate"},"3.2.2"),". The main block processing function during init sync is the function ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block.go#L282"},"onBlockBatch"),". This function does essentially the same processing as ",(0,a.kt)("inlineCode",{parentName:"p"},"onBlock")," but it takes consecutive batches of blocks to do signature verification by aggregation. In what regards to optimistic syncing the behavior is the same as in regular sync: for each block a call to  ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload")," is made. However only after the full batch has been processed and verified, it is inserted in forkchoice. Only the last block inserted is considered for optimistic sync, namely if this block is VALID, then the whole batch is considered VALID, otherwise the whole batch is considered optimistic. Since the batch is linear, we only call ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate")," in the last block of the batch."),(0,a.kt)("h3",{id:"33-grpc-api"},"3.3 (g)RPC API"),(0,a.kt)("p",null,"A CLC is required to respond to requests for blocks, state information, head information, etc. The node is required to provide optimistic status information in its reply. Many of the endpoints simply add a JSON field ",(0,a.kt)("inlineCode",{parentName:"p"},"is_optimistic")," that results ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," when the corresponding block has been inserted optimistically or ",(0,a.kt)("inlineCode",{parentName:"p"},"false")," when it has been fully validated. The Agora node ultimately calls the two functions ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/chain_info.go#L301"},"IsOptimistic")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/chain_info.go#L322"},"IsOptimisticForRoot"),"."),(0,a.kt)("p",null,"The former is just a wrapper around the latter, it fetches the head root of the node and calls the latter. The latter returns whether the block with the given root is optimistic. It does so by calling first forkchoice's ",(0,a.kt)("inlineCode",{parentName:"p"},"IsOptimistic")," and if it fails it checks with the database as explained in the next section."),(0,a.kt)("p",null,"Perhaps the most important impact that optmistic sync has on the API section, is that when the validator calls ",(0,a.kt)("inlineCode",{parentName:"p"},"GetBlock")," to obtain a new block to propose, or when it calls ",(0,a.kt)("inlineCode",{parentName:"p"},"GetAttestationData")," to obtain an attestation and so forth, for each of the validator duties, the corresponding RPC calls include a call to check the optimistic status of the node as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"// An optimistic validator MUST NOT participate in attestation. (i.e., sign across the DOMAIN_BEACON_ATTESTER, DOMAIN_SELECTION_PROOF or DOMAIN_AGGREGATE_AND_PROOF domains).\nif err := vs.optimisticStatus(ctx); err != nil {\n      return nil, err\n}\n")),(0,a.kt)("p",null,"It is important, and dangerous to not act in optimistic node. From a network perspective because it may lead to finalization/justification of an invalid chain. And from a selfish perspective because it may lead to slashing eventually when we slash validators for attesting on invalid payloads."),(0,a.kt)("h3",{id:"34-database"},"3.4 Database"),(0,a.kt)("p",null,"We have described in section ",(0,a.kt)("a",{parentName:"p",href:"#31-forkchoice-package"},"3.1")," that the forkchoice package is responsible for tracking the optimistic status of imported nodes. Forkchoice however prunes nodes after finalization and we can finalize during optimistic mode. If we require optimistic information about an ancient block we request this information from the database. The database tracks the last ",(0,a.kt)("em",{parentName:"p"},"validated checkpoint"),". This is a checkpoint by which any canonical block older than it is considered VALID, and any block that is not in forkchoice and that is newer than the last validated checkpoint, is optimistic. The function to obtain this information is ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/db/kv/validated_checkpoint.go#L13"},"LastValidatedCheckpoint"),"."),(0,a.kt)("p",null,"Notice that any orphaned block in the database, even those older than the last validated checkpoint, will be served as  optimistic, even though they may have been fully validated. This is a compromise to avoid complicated setups as we ",(0,a.kt)("a",{parentName:"p",href:"https://www.notion.so/Bosagora/Optimistic-blocks-storage-05d0832243ce46b4bd36e422e8f8e15f#85e6baf047eb4d16b9d0fc2ca6ad8569"},"previously had designed"),"."),(0,a.kt)("p",null,"The last validated checkpoint is updated only when we finalize a new checkpoint and thus its pruned from forkchoice. The corresponding function is ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/db/kv/validated_checkpoint.go#L32"},"SaveLastValidatedCheckpoint")," and is called from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/blockchain/process_block_helpers.go#L139"},"updateFinalized"),". This latter function is called both from ",(0,a.kt)("inlineCode",{parentName:"p"},"onBlock")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"onBlockBatch")," when processing a block in regular or init sync that updates finalization."),(0,a.kt)("h2",{id:"4-some-edge-cases-and-unsolved-problems"},"4 Some edge cases and unsolved problems"),(0,a.kt)("h3",{id:"41-justification-reversal-after-pruning"},"4.1 Justification reversal after pruning"),(0,a.kt)("p",null,"Most of the edge cases with optimistic sync happen in the presence of invalid payload. We have already described the situation with ",(0,a.kt)("a",{parentName:"p",href:"#forkchoice-poisoning"},"Forkchoice Poisoning"),". The following similar situations have been described in the open issues ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/10782"},"10782")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/107770"},"10777"),". They are variations of the same phenomenon: an INVALID chain is imported and it updates justification, even though the justification checkpoint is VALID, the node may be deadlocked."),(0,a.kt)("p",null,"Consider the following diagram:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://i.imgur.com/N3b9LMM.jpg",alt:null})),(0,a.kt)("p",null,"At the beginning of Epoch 10 the justified epoch is 9, the justified checkpoint is pointed by block ",(0,a.kt)("inlineCode",{parentName:"p"},"A"),". The epoch advances fine but the ELC is still syncing, therefore this node is taking blocks optimistically. Block ",(0,a.kt)("inlineCode",{parentName:"p"},"C"),"  in epoch 10 may have or may not have enough attestations to justify Epoch 10, but its own post-state justification checkpoint is still block ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," in Epoch 9, as justification is updated only on epoch processing.  Block ",(0,a.kt)("inlineCode",{parentName:"p"},"D")," is the first block imported in epoch 11 and it is the first one to justify block B in epoch 10. At this point the forkchoice store's justification checkpoint updates to block ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," in epoch 10. The chain advances and when importing the block ",(0,a.kt)("inlineCode",{parentName:"p"},"E")," the ELC has fully synced and returns INVALID, with a LVH pointing to the fork block ",(0,a.kt)("inlineCode",{parentName:"p"},"X"),". We call forkchoice's ",(0,a.kt)("inlineCode",{parentName:"p"},"SetOptimisticToInvalid")," and remove all invalid blocks in the chain ",(0,a.kt)("inlineCode",{parentName:"p"},"D"),"--",(0,a.kt)("inlineCode",{parentName:"p"}," E")," . How should we update Head? the block ",(0,a.kt)("inlineCode",{parentName:"p"},"C")," is not eligible for head since its justification point is ",(0,a.kt)("inlineCode",{parentName:"p"},"A")," with Epoch 9 and the store's justification is ",(0,a.kt)("inlineCode",{parentName:"p"},"B")," with Epoch 10. At this point the node is deadlocked. It cannot import any block unless the very next block that is imported realizes the justification at Epoch 10. If it doesn't it will fail in the same way, by not being eligible for Head, and therefore that node (and possibly all the honest chain built on it) will never be imported."),(0,a.kt)("p",null,"Notice that this may happen during optimistic syncing of the merge block, precisely in the situation that the ",(0,a.kt)("a",{parentName:"p",href:"#forkchoice-poisoning"},"forkchoice poisoning")," attack described. In this case, even with the prevision of ",(0,a.kt)("inlineCode",{parentName:"p"},"SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY"),", we would be deadlocked."),(0,a.kt)("p",null,"We could revert justification, but this becomes very hard to implement and standardize across clients since we do not keep track of when the justification has changed. What Teku does is allow head to be the last justified checkpoint, in this case it would be ",(0,a.kt)("inlineCode",{parentName:"p"},"B"),". But that would make the node behave as it would be non-optimistic and lead to problems if a big part of the network is in optimistic mode. An option we are considering is to make the node be optimistic if the head is optimistic or if the head is the justified checkpoint, as the justified checkpoint can never be head except when it is the genesis checkpoint or the first slot when we are using checkpoint sync."),(0,a.kt)("p",null,"This problem was found independently by many and there are different ad-hoc implementations to fix them, but clients currently diverge in their behavior at this point."),(0,a.kt)("h3",{id:"42-timeouts-and-unhandled-errors"},"4.2 Timeouts and unhandled errors"),(0,a.kt)("p",null,"Another common themes for bugs with optimistic sync is the handling of timeouts and unhandled errors from the ELC. When the ELC timesout on a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload"),", it has not replied neither saying that it has fully validated the block nor that it is SYNCING. Ironically, this means that a node that was previously lock-stepping is not to be considered optimistic and can actually attest to its previous head, and propose a block based on its previous head. We are not allowed however to import a block which the ELC has not returned of of VALID, INVALID, ACCEPTED or SYNCING. The following situation has happened in a couple of merged networks and shadow forks: the ELC timesout the CLC does not send any new payload since it can't import any block. The CLC should consider resending either ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyNewPayload"),"  or ",(0,a.kt)("inlineCode",{parentName:"p"},"notifyForkchoiceUpdate")," to the ELC if it has timedout and the CLC is not importing a new block because of this."),(0,a.kt)(s.M,{mdxType:"RequestUpdateWidget"}))}m.isMDXComponent=!0}}]);