"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9929],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=o,m=u["".concat(l,".").concat(d)]||u[d]||p[d]||r;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1262:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294),o=n(2263);const r=function(e){var t=e.children,n=e.fallback;return(0,o.Z)().isClient&&null!=t?a.createElement(a.Fragment,null,t()):n||null}},8215:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);const o=function(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:o},t)}},5064:(e,t,n)=>{n.d(t,{Z:()=>p});var a=n(7294),o=n(9443);const r=function(){var e=(0,a.useContext)(o.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e};var i=n(6010);const s="tabItem_1uMI",l="tabItemActive_2DSg";var c=37,h=39;const p=function(e){var t=e.lazy,n=e.block,o=e.defaultValue,p=e.values,u=e.groupId,d=e.className,m=r(),f=m.tabGroupChoices,b=m.setTabGroupChoices,k=(0,a.useState)(o),g=k[0],y=k[1],v=a.Children.toArray(e.children),w=[];if(null!=u){var N=f[u];null!=N&&N!==g&&p.some((function(e){return e.value===N}))&&y(N)}var S=function(e){var t=e.currentTarget,n=w.indexOf(t),a=p[n].value;y(a),null!=u&&(b(u,a),setTimeout((function(){var e,n,a,o,r,i,s,c;(e=t.getBoundingClientRect(),n=e.top,a=e.left,o=e.bottom,r=e.right,i=window,s=i.innerHeight,c=i.innerWidth,n>=0&&r<=c&&o<=s&&a>=0)||(t.scrollIntoView({block:"center",behavior:"smooth"}),t.classList.add(l),setTimeout((function(){return t.classList.remove(l)}),2e3))}),150))},z=function(e){var t,n;switch(e.keyCode){case h:var a=w.indexOf(e.target)+1;n=w[a]||w[0];break;case c:var o=w.indexOf(e.target)-1;n=w[o]||w[w.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},d)},p.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:g===t?0:-1,"aria-selected":g===t,className:(0,i.Z)("tabs__item",s,{"tabs__item--active":g===t}),key:t,ref:function(e){return w.push(e)},onKeyDown:z,onFocus:S,onClick:S},n)}))),t?(0,a.cloneElement)(v.filter((function(e){return e.props.value===g}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},v.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==g})}))))}},9443:(e,t,n)=>{n.d(t,{Z:()=>a});const a=(0,n(7294).createContext)(void 0)},5505:(e,t,n)=>{n.d(t,{M:()=>r});var a=n(7294),o=n(1262),r=function(e){var t=e.commaDelimitedContributors,n=e.lastVerifiedDateString,r=e.lastVerifiedVersionString,i={Chris:"hewison-chris"},s=function(e){return a.createElement("a",{class:"header-badge",href:"https://github.com/"+i[e]},a.createElement("span",{class:"badge-avatar",style:{backgroundImage:"url('https://avatars.githubusercontent.com/"+i[e]+"')"}}),a.createElement("span",{class:"badge-label"},e))};return a.createElement(o.Z,null,(function(){return a.createElement("div",{class:"header-badges"},null!=t?t.split(",").map(s):null,function(e,t){if(null!=e&&null!=t)return a.createElement("a",{class:"header-badge"},a.createElement("span",{class:"badge-avatar emoji-avatar"},"\u2714\ufe0f"),a.createElement("span",{class:"badge-label"},"Last verified on ",a.createElement("strong",null,e)," using Agora-cl ",t))}(n,r),a.createElement("a",{class:"header-badge",href:"https://github.com/Bosagora/documentation/issues/new?title=Docs update request: "+new URL(window.location.href).pathname+"&body=Source: "+window.location.href+"%0A%0ARequest: (how can we help?)"},a.createElement("span",{class:"badge-avatar emoji-avatar"},"\u270f\ufe0f"),a.createElement("span",{class:"badge-label"},"Request an update")))}))}},1144:(e,t,n)=>{n.d(t,{M:()=>r});var a=n(7294),o=n(1262),r=function(e){return function(e){if(null==e)throw new TypeError("Cannot destructure undefined")}(e),a.createElement(o.Z,null,(function(){return a.createElement("div",{class:"update-request"},a.createElement("a",{href:"https://https://github.com/zeroone-boa/agora-cl-docs/issues/new?title=Docs update request: "+new URL(window.location.href).pathname+"&body=Source: "+window.location.href+"%0A%0ARequest: (how can we help?)"},"\ud83d\udc3c Request an update"))}))}},9780:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>h,default:()=>m,frontMatter:()=>c,metadata:()=>p,toc:()=>u});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=n(5505),s=(n(5064),n(8215),n(1144)),l=["components"],c={id:"init-state",title:"Initial synchronization",sidebar_label:"Initial synchronization"},h=void 0,p={unversionedId:"devtools/init-state",id:"devtools/init-state",isDocsHomePage:!1,title:"Initial synchronization",description:"Overview of the Feature",source:"@site/docs/devtools/init-state.md",sourceDirName:"devtools",slug:"/devtools/init-state",permalink:"/docs/devtools/init-state",editUrl:"https://github.com/zeroone-boa/agora-cl-docs/edit/master/website/docs/devtools/init-state.md",version:"current",frontMatter:{id:"init-state",title:"Initial synchronization",sidebar_label:"Initial synchronization"},sidebar:"docs",previous:{title:"Keymanager APIs",permalink:"/docs/how-agora-cl-works/keymanager-api"},next:{title:"Network design",permalink:"/docs/devtools/net-design"}},u=[{value:"Overview of the Feature",id:"overview-of-the-feature",children:[]},{value:"Design Overview",id:"design-overview",children:[]},{value:"High Level Design of the Solution",id:"high-level-design-of-the-solution",children:[]},{value:"Service Design Diagram",id:"service-design-diagram",children:[]},{value:"FSM State Transitions Diagram",id:"fsm-state-transitions-diagram",children:[]},{value:"Architectural Overview",id:"architectural-overview",children:[{value:"Blocks Queue",id:"blocks-queue",children:[]},{value:"FSM Manager and FSMs",id:"fsm-manager-and-fsms",children:[]},{value:"Blocks Fetcher",id:"blocks-fetcher",children:[]},{value:"Backtracking procedure",id:"backtracking-procedure",children:[]},{value:"Handling skipped blocks",id:"handling-skipped-blocks",children:[]},{value:"Utilizing peer scorer",id:"utilizing-peer-scorer",children:[]}]},{value:"Testing",id:"testing",children:[]}],d={toc:u};function m(e){var t=e.components,c=(0,o.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},d,c,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(i.M,{mdxType:"HeaderBadgesWidget"}),(0,r.kt)("h2",{id:"overview-of-the-feature"},"Overview of the Feature"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"What the feature is for:")),(0,r.kt)("p",null,"Initial sync serves the following purposes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Synchronizing from the last known node\u2019s head (can be at genesis) to the highest finalized epoch known by the surrounding peers.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Synchronizing from the finalized checkpoint to the surrounding peers\u2019 best known non-finalized epoch.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Fallback synchronization mechanism when node falls behind its peers while performing the regular synchronization."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Where the feature lives in Agora-cl:")," The feature is fully contained within the following folder/package: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/tree/develop/beacon-chain/sync/initial-sync"},"/beacon-chain/sync/initial-sync/")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Technologies used:")," ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/libp2p/go-libp2p"},"go-libp2p")),(0,r.kt)("h2",{id:"design-overview"},"Design Overview"),(0,r.kt)("p",null,"What problems are being addressed:"),(0,r.kt)("p",null,"The challenges for the initial sync implementers can be summarized as the following;"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Peers surrounding the node can be bogus, non-responsive or even evil (that\u2019s serving incoherent or wrong data on purpose). The trick is to make sure that blocks are being processed at a high pace, with good peers utilized to the fullest without danger of being eclipsed i.e. whether peer is considered good/bad is highly dependent on context and is dynamic in nature, so peer status should be updated regularly and a bad peer now may be a good choice to fetch from at some future moment.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Incoming block list is sequential, but in order to utilize available resources better and increase throughput, we need to fetch data concurrently. That can be redundant at times, and it is important to make sure that block processors are not caught in livelock (where they are just spinning on the very same redundant data), nor starving (when they are processing blocks at a higher pace than block fetchers are capable of providing).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When it comes to the non-finalized part of the chain, everything becomes a bit more complicated: at this point node\u2019s known head is not finalized, thus can be changed, and initial sync algorithms should be aware of this (and re-request some previous range if necessary). This capability becomes crucial when it comes to long periods of non-finality where it\u2019s critically important to allow nodes to synchronize to the highest epoch possible, yet backtrack (if necessary) to some previous ancestor to allow fork choice to select another branch to build upon.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Blocks are created during time slots, but some slots might have skipped/missing blocks, and the synchronization routine must be capable of finding the next non-skipped slot even if the gap is measured in thousands of slots.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Sometimes (especially exacerbated during long periods of non-finality) nodes can get stuck in an unfavourable fork, the synchronization routine must have capability to backtrack and explore other forks, ideally without too much time spent on spinning in that unfortunate fork.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Whenever there\u2019s a problem with regular synchronization, initial synchronization serves as a fallback mechanism to catch up on peers. Therefore, it must be robust enough to proceed in spite of problems that caused the node to fall behind the peers in the first place."))),(0,r.kt)("h2",{id:"high-level-design-of-the-solution"},"High Level Design of the Solution"),(0,r.kt)("p",null,"Essentially synchronization is split into two phases: from the state at which the node is started to the finalized checkpoint (as reported by majority of peers) and, then, if necessary, from that finalized checkpoint till the best known state (we have a minimum number of peers that are expected to support that state, before considering synchronization toward that head)."),(0,r.kt)("p",null,"Both described phases utilize the very same synchronization mechanism: queue of blocks, which guarantees that incoming blocks will be in sequential order, block processors will never starve (the queue will always have some blocks waiting), and that with acceptable amount of redundant requests queue avoids livelocks by providing blocks that are capable of advancing the state."),(0,r.kt)("p",null,"To keep track of the state, the queue utilizes finite state machines (FSMs): blocks are requested in batches, with each batch range of blocks assigned to one of available state machines, and within queue there\u2019s a ticker that is constantly checking the state of each individual machine allowing them to apply actions to deterministically transit into the next state:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"State(S) x Event(E) -> Actions (A), State(S')")),(0,r.kt)("p",null,"(here E - is normally a tick event, and actions are selected from available event handlers depending on the initial state S)."),(0,r.kt)("p",null,"FSMs are responsible for managing state transitions (fetch request queued, block batch requested, blocks received, data processed etc), but the actual fetching of data is handled by another major component of the init-sync system: block fetcher. This is done to decouple block queuing and actual block fetching: different state machines request different ranges concurrently. Of course, this may end up in some redundancy (when the earliest machine\u2019s blocks are on some wrong fork and the next FSMs cannot proceed without resetting and re-requesting data of that first machine)."),(0,r.kt)("h2",{id:"service-design-diagram"},"Service Design Diagram"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Service Diagram",src:n(5622).Z})),(0,r.kt)("h2",{id:"fsm-state-transitions-diagram"},"FSM State Transitions Diagram"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"FSM State Transitions Diagram",src:n(7051).Z})),(0,r.kt)("h2",{id:"architectural-overview"},"Architectural Overview"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Structure of the feature (is it a service, a tool, a background routine?)")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Initial synchronization is implemented as a separate service, loadable into service registry.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Components of the feature")),(0,r.kt)("p",null,"Initial Synchronization Service"),(0,r.kt)("p",null,"Available synchronization functionality is exposed via ",(0,r.kt)("inlineCode",{parentName:"p"},"initalsync.Service"),", with two major methods: ",(0,r.kt)("inlineCode",{parentName:"p"},"Start()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Resync()"),". The former is responsible for initialization of the service and the first synchronization after the node\u2019s initial start and the latter is called when Agora node falls behind during the normal synchronization, and needs to resync using a more robust initial synchronization mechanism."),(0,r.kt)("p",null,"Another purpose of the service object is to be the glue between blocks queue and blocks processor: it makes sure that the queue is started and blocks received are forwarded to the processor."),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/service.go#L46"},"service.go"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/beacon-chain/sync/initial-sync/round_robin.go"},"round_robin.go")),(0,r.kt)("h3",{id:"blocks-queue"},"Blocks Queue"),(0,r.kt)("p",null,"Blocks queue is the core component managing higher level block fetching from the surrounding peers."),(0,r.kt)("p",null,"Queue operates in the following manner:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"When started, queue creates the internal fetcher service, which is responsible for lower level data fetching functionality i.e. queue manages the overall scheduling process, while blocks fetcher is responsible for talking to peers, requesting and processing their data (see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L100"},"blocks_queue.go:newBlocksQueue"),". Block fetcher exposes the output channel which the queue keeps waiting on up until all the necessary blocks are fetched, at that point the queue closes the fetcher's context thus closing that sub-service as well see: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L255"},"blocks_queue.go:loop"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"In order to keep FSMs as lightweight as possible, queue registers event handlers with itself instead of registering them with each individual machine. Each handler function accepts FSM as an argument (thus event handlers are fully aware on which machine they operate on).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Queue relies on the FSM manager to create/remove FSMs. In order to allow concurrent scheduling of different batches of blocks, queue relies on several machines (currently 8). FSMs are used to track the state of different block request ranges (whether blocks in that range have been requested, already fetched, sent down the pipeline etc).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Once the fetcher is initialized and event handlers are registered, the queue enters an event listening ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L165"},"loop"),", with only two available event types: ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Data Received"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," event is nothing more than a time ticker triggering different events handlers on FSMs (depending on their current state) on a regular basis (currently every 200 milliseconds). The ",(0,r.kt)("inlineCode",{parentName:"p"},"Data received")," event is triggered asynchronously on read from the output channel of the fetcher i.e. when the fetcher returns some data to parse and pass over to block processors."))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Available events handlers:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"On schedule:")," this event handler is triggered when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," event occurs on a machine in a ",(0,r.kt)("inlineCode",{parentName:"p"},"New")," state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"On data received:")," this event handler is triggered when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Data Received")," event occurs on a machine (if machine is not in ",(0,r.kt)("inlineCode",{parentName:"p"},"Scheduled")," state, incoming data is ignored).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"On ready to send:")," this event handler is triggered when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," event occurs on a machine with ",(0,r.kt)("inlineCode",{parentName:"p"},"Data Parsed")," state i.e. machine that has incoming data placed into it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"On a stale machine:")," this event handler is triggered when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," event occurs on an unresponsive machine, the main purpose of this handler is to mark the machine as skipped, so that ",(0,r.kt)("inlineCode",{parentName:"p"},"On a skipped machine")," handler resets it.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("em",{parentName:"p"},"On a skipped machine:")," this event handler is triggered when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," event occurs on a stuck machine, that's a machine that stays in a given state for too long, and is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"Skipped"),", this handler is responsible for resetting such machines."))),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L73"},"blocks_queue.go"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L281"},"Queue.onScheduleEvent()"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L299"},"Queue.onDataReceivedEvent()"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L334"},"Queue.onReadyToSendEvent()"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L383"},"Queue.onProcessSkippedEvent()"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L442"},"Queue.onCheckStaleEvent()")),(0,r.kt)("h3",{id:"fsm-manager-and-fsms"},"FSM Manager and FSMs"),(0,r.kt)("p",null,"Each FSM ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/fsm.go#L43"},"(see fsm.go:stateMachine)"),"  has the following data associated with it:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Start Slot:")," beginning of the range of blocks to pull into a given machine. The end slot is determined by the batch size, which is a predefined constant (currently 64)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Peer ID:")," identifies a peer that was used to fetch blocks into a given state machine; provided by fetcher via its output channel."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Blocks:")," fetched blocks; provided by the fetcher via its output channel."),(0,r.kt)("p",null,"FSM Manager is a container used to group machines together, for easier management and traversal. It is queue\u2019s responsibility to make sure that ",(0,r.kt)("inlineCode",{parentName:"p"},"Start Slot")," uniquely identifies the machine: there\u2019s no point in having a machine with the same start slots, as machines are fetching batches of a constant size starting from the start slot, therefore machines with the same start slot will essentially fetch the same block range (albeit, possibly, from the different peers). Of course sometimes such a redundancy is unavoidable: in cases when the Agora node\u2019s head cannot be advanced, machines with slots equal to that of some previously used machines can be spawned (see how machines are reset in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L419"},"onProcessSkippedEvent()")," event handler)."),(0,r.kt)("p",null,"While event handlers operate on FSMs, they are not registered with machines themselves but with the queue, this is done for reasons of efficiency (machines are constantly removed and re-added, so are kept as simple as possible). When an event occurs (for example ",(0,r.kt)("inlineCode",{parentName:"p"},"Tick")," event occurs every 200 milliseconds), each known FSM is passed to the corresponding event handler, depending on FSM\u2019s current state. Here is the list of event handlers, required FSM start states and their corresponding handlers:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Event"),(0,r.kt)("th",{parentName:"tr",align:null},"Required FSM state"),(0,r.kt)("th",{parentName:"tr",align:null},"Event Handler"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Tick"),(0,r.kt)("td",{parentName:"tr",align:null},"New"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L281"},"Queue.onScheduleEvent()"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Tick"),(0,r.kt)("td",{parentName:"tr",align:null},"Data parsed"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L334"},"Queue.onReadyToSendEvent()"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Tick"),(0,r.kt)("td",{parentName:"tr",align:null},"Skipped"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L383"},"Queue.onProcessSkippedEvent()"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Tick"),(0,r.kt)("td",{parentName:"tr",align:null},"Sent"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L442"},"Queue.onCheckStaleEvent()"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data Received"),(0,r.kt)("td",{parentName:"tr",align:null},"Scheduled"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L299"},"Queue.onDataReceivedEvent()"))))),(0,r.kt)("p",null,"The above table is easy to read: for example it is easy to see that in order for an FSM to be passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"onDataReceivedEvent()")," handler, it must be in a ",(0,r.kt)("inlineCode",{parentName:"p"},"Scheduled")," state and ",(0,r.kt)("inlineCode",{parentName:"p"},"Data Received")," event must occur (that\u2019s fetcher should write something into its output channel)."),(0,r.kt)("p",null,"Below is a state transition table (depending on input there might be several possible transitions for a given event -- only one of which is valid, as our FSMs are deterministic):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"State/Event"),(0,r.kt)("th",{parentName:"tr",align:null},"New"),(0,r.kt)("th",{parentName:"tr",align:null},"Scheduled"),(0,r.kt)("th",{parentName:"tr",align:null},"Data Parsed"),(0,r.kt)("th",{parentName:"tr",align:null},"Skipped"),(0,r.kt)("th",{parentName:"tr",align:null},"Data Sent"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Tick")),(0,r.kt)("td",{parentName:"tr",align:null},"Scheduled Skipped"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Data Sent Skipped"),(0,r.kt)("td",{parentName:"tr",align:null},"New"),(0,r.kt)("td",{parentName:"tr",align:null},"New Skipped")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Data Received")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Data Parsed New"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("p",null,"Refer to ",(0,r.kt)("a",{parentName:"p",href:"#fsm-state-transitions-diagram"},"FSM state transitions diagram")," for further details."),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/fsm.go#L35"},"fsm.go:stateMachineManager")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Machines lifetime")),(0,r.kt)("p",null,"When queue operates, FSMs are constantly being created and removed:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Whenever a queue has less than a ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L31"},"predefined")," number of machines (currently 8), a new machine is added."),(0,r.kt)("li",{parentName:"ul"},"Once a machine is outdated (its data is processed, or it features a block range that has already been passed by the currently known head, or it is in a stuck or invalid state), it is removed from the FSM manager.")),(0,r.kt)("p",null,"This is done to optimize the runtime and make code more simple to understand (had we decided to reuse the machines it would have required a lot of orchestration code - but right now, queue implementation is very simple and gets the job done)."),(0,r.kt)("p",null,"So, whenever we need to implement some complex algorithm it almost always has to do with creating a new state machine of a particular configuration. For instance, see ",(0,r.kt)("a",{parentName:"p",href:"#handling-skipped-blocks"},"Handling Skipped Slots section")," and how finding the first non-skipped slot is implemented using a machine with a start slot set to some high future epoch."),(0,r.kt)("p",null,"Being able to algorithmically select a range of blocks (which will be reset if stuck, and if it gets blocks, those blocks will be eventually pushed into the queue and towards the block processors -- automatically) is one of the main benefits of using FSMs."),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue_utils.go#L11"},"blocks_queue_utils.go:resetFromFork()")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue_utils.go#L44"},"blocks_queue_utils.go:resetFromSlot()")),(0,r.kt)("h3",{id:"blocks-fetcher"},"Blocks Fetcher"),(0,r.kt)("p",null,"The fetcher component (see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue_utils.go#L44"},"blocks_fetcher.go:blocksFetcher"),") is responsible for handling p2p communication, and does the actual data requesting and fetching. It is a very simple component operating in the following way:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Fetcher manages two channels: one for incoming fetching requests and the other for sending fetched data back to requesters. All this is done asynchronously, of course!")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Fetcher is smart enough to honour rate limits and while being highly concurrent, never requests at a higher pace than is allowed by Agora-cl beacon nodes (see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher_peers.go#L21"},"getPeerLock()"),"). So, fetching nodes should never receive a bad score from fellow Agora-cl peers (while it is theoretically possible that other clients still consider our fetcher aggressive, in reality Agora-cl has one of the strictest limits, thus in practice this has never happened).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"All the low level details (like checking that enough peers are available, filtering out less useful peers, handling p2p errors) of data requesting is abstracted within the fetcher service."))),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher.go#L68"},"blocks_fetcher.go"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher_peers.go#L1"},"blocks_fetcher_peers.go"),", ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher_utils.go#L1"},"blocks_fetcher_utils.go")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Noteworthy code in the feature")),(0,r.kt)("p",null,"There are several very interesting add-ons to the main synchronization procedure, making it more robust and useful. In this section, we will briefly cover them (feel free to dive into the code deeper -- it should be easy to follow)."),(0,r.kt)("h3",{id:"backtracking-procedure"},"Backtracking procedure"),(0,r.kt)("p",null,"Normally, there are no more than a handful of non-finalized epochs, and once initial synchronization is complete, the regular synchronization is capable of proceeding by obtaining new blocks, validating them, and applying fork-choice rule. But occasionally, the whole network is unable to reach consensus and forked branches start to occur, and can even get quite long. This is especially prevalent during test networks (see ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/prysmatic-labs/eth2-medalla-testnet-incident-f7fbc3cc934a"},"Medalla Incident")," post-mortem), where there\u2019s no real ether at stake."),(0,r.kt)("p",null,"Regular synchronization cannot handle such fork branching, and node eventually falls behind the highest expected slot (if counting time slots from the genesis up to the current clock time). Once that happens, the system falls back to initial synchronization, which needs to be able to not only synchronize with the majority of  known peers, but handle the case when that majority is dynamic i.e. be capable to backtrack from some unfavourable fork, which is no longer voted for by the current majority of known peers (while it was supported by previous majority just 10 minutes ago!)."),(0,r.kt)("p",null,"Our backtracking algorithm is pretty simple (code is abridged, see full version ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher_utils.go#L1470"},"here"),":)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// findFork queries all peers that have higher head slot, in an attempt to find\n// ones that feature blocks from alternative branches. Once found, peer is\n// further queried to find a common ancestor slot.\nfunc (f *blocksFetcher) findFork(..., slot uint64) (*forkData, error) {\n    // some details are skipped..\n   // Select peers that have a higher head slot, and potentially blocks\n      // from a more favourable fork.\n    _, peers := f.p2p.Peers().BestNonFinalized(1, epoch+1)\n    f.rand.Shuffle(len(peers), func(i, j int) {\n        peers[i], peers[j] = peers[j], peers[i]\n    })\n\n    // Query all found peers, stop on peer with alternative blocks,\n      // and try backtracking.\n    for i, pid := range peers {\n        fork, err := f.findForkWithPeer(ctx, pid, slot)\n        if err != nil {\n            continue\n        }\n        return fork, nil\n    }\n    return nil, errNoPeersWithAltBlocks\n}\n\n")),(0,r.kt)("p",null,"Essentially, all we are doing is querying our peer list for peers with a non-finalized known slot higher than that which our node was able to progress to. Then, out of those peers, the peers list is randomized and they are queried to find a peer with blocks our node hasn\u2019t as yet seen. Once such a peer is found, we need to backtrack (hence the name!) on that peer from the slot starting at our node\u2019s head backwards in history until the common ancestor block is found (or until the predefined limit is reached, to avoid infinite/overly long loops). Once a common ancestor is found, node tries to build on top of that alternative fork. While seemingly trivial, this procedure has worked extremely well."),(0,r.kt)("h3",{id:"handling-skipped-blocks"},"Handling skipped blocks"),(0,r.kt)("p",null,"At each slot a block can be proposed. If this doesn\u2019t happen, the block is considered as skipped. There might be lots of consecutive skipped blocks, but our queue has only 8 FSMs (so, can look no further than 8x64 = 512 blocks \u201cinto the future\u201d). How do you overcome such a limitation, where the normal queue range of vision is 512 next slots, and the first non-skipped block is 10K+ slots away?"),(0,r.kt)("p",null,"A simple trick is used: when all machines are in ",(0,r.kt)("inlineCode",{parentName:"p"},"Skipped")," state, meaning we are stuck, the first 7 machines are reset normally (",(0,r.kt)("strong",{parentName:"p"},"the first machine's starting slot is the current known head slot, the second machine is +64 slots, and so on, and so forth"),"), but the last state machine is reset from a slot, possibly very far in future, where the first non-skipped block is found. So, if the last machine is set to start fetching within range where the next non-skipped block lives, then it will be able to fetch that block, and thus advance our node\u2019s head slot. The only problem is finding that starting slot for this last FSM, and doing so efficiently i.e. without simply querying each and every slot up until we find a non-empty one (which can be 10K+ slots away)."),(0,r.kt)("p",null,"We\u2019ve devised an algorithm that is capable of looking ahead 50K+ slots (instead of only 512), and even further (for 50K we have unit tests proving the statement):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"nonSkippedSlotAfter(slot):\n    head := chain head on which peers agree (we filter and shuffle peers)\n    check fist n (currently n = 10) epochs, fully, slot by slot\n        if non-skipped slot found return, if not then resort to random sampling\n    for every epoch in (slot+n*32 to best known head]:\n        select and check random slot (one for each epoch)\n        if slot is non-skipped log it and break out of the loop\n    with found non-skipped slot:\n        find surrounding epochs and pull all the blocks\n          (to find the first non-skipped slot)\n        when block with slot > than argument slot is found, return it\n")),(0,r.kt)("p",null,"And the corresponding implementation can be found in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher_utils.go#L34"},"blocks_fetcher_utils.go:nonSkippedSlotAfter"),", here it signature:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// nonSkippedSlotAfter checks slots after the given one in an attempt to find\n// a non-empty future slot.\n// For efficiency only one random slot is checked per epoch, so returned slot\n//  might not be the first non-skipped slot. This shouldn't be a problem, as\n// in case of adversary peer, we might get incorrect data anyway, so code that\n// relies on this function must be robust enough to re-request, if no progress\n// is possible with a returned value.\nfunc (f *blocksFetcher) nonSkippedSlotAfter(slot uint64) (uint64, error) {}\n")),(0,r.kt)("p",null,"The procedure is quite optimized, for instance, within a single request, node samples 16 future epochs are at once (so the pace is 16x32=512 blocks/request, when looking for a non-skipped slot). Hence even non-skipped slots which are significantly in the futre are found very quickly."),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue.go#L383"},"blocks_queue.go:onProcessSkippedEvent()")),(0,r.kt)("h3",{id:"utilizing-peer-scorer"},"Utilizing peer scorer"),(0,r.kt)("p",null,"Since we are dealing with a public decentralized network, we cannot assume that each peer behaves correctly, and there might be bogus, unresponsive, or even malicious peers."),(0,r.kt)("p",null,"In order to avoid being stuck with a single unresponsive peer, our first fetcher implementation shuffled peers before selecting one to fetch data from. We have improved upon this method and now score peers on their behaviour and increase the probability of selecting high scoring peers, thus utilizing our mesh more efficiently."),(0,r.kt)("p",null,"We have quite sophisticated scoring mechanisms already in place, and we\u2019re ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/6622"},"continuingly")," building on them. Currently, the peer scorer service is able to track peer\u2019s performance (on how many requests, how many useful blocks -- that\u2019s blocks advancing the head -- have been returned). Peers scoring higher will have a better chance of being selected (see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_fetcher_peers.go#L94"},"blocks_fetcher_peers.go")," for full code):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// filterPeers returns a transformed list of peers, weight sorted by scores\n// and capacity remaining.\n// List can be further constrained using peersPercentage, where only\n// percentage of peers are returned.\nfunc (f *blocksFetcher) filterPeers(... peers []peer.ID, peersPercentage float64) []peer.ID {\n    // Sort peers using both block provider score and, custom, capacity\n      // based score (see peerFilterCapacityWeight if you want to give\n      // different weights to provider's and capacity scores).\n    // Scores produced are used as weights, so peers are ordered\n      // probabilistically i.e. peer with\n    // a higher score has a higher chance to end up higher in the list.\n    scorer := f.p2p.Peers().Scorers().BlockProviderScorer()\n    peers = scorer.WeightSorted(f.rand, peers, func(\n        peerID peer.ID, blockProviderScore float64) float64 {\n        remaining, capacity := float64(f.rateLimiter.Remaining(peerID.String())), float64(f.rateLimiter.Capacity())\n        // When capacity is close to exhaustion, allow less performant peers\n            // to take a chance.\n        // Otherwise, there's a good chance the system will be forced to\n            // wait for the rate limiter.\n        if remaining < float64(f.blocksPerSecond) {\n            return 0.0\n        }\n        capScore := remaining / capacity\n        overallScore := blockProviderScore*(1.0-f.capacityWeight) + capScore*f.capacityWeight\n        return math.Round(overallScore*scorers.ScoreRoundingFactor) / scorers.ScoreRoundingFactor\n    })\n\n    return trimPeers(peers, peersPercentage)\n}\n\n")),(0,r.kt)("p",null,"Not only do we filter by score, we also take into account the remaining capacity of a peer (capacity being the number of blocks left, before the rate limiter will be triggered and requests to the peer are blocked for a short period of time until capacity is restored)."),(0,r.kt)("h2",{id:"testing"},"Testing"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Unit tests and mocks, how to write tests for the feature:"),"\nSince initial synchronization interacts heavily with the P2P layer, we rely on mocks to simulate network mesh. The easiest way to start the test is to use ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/initial_sync_test.go#L74"},"initializeTestServices()"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Get chain, network, and database objects.\n// You can provide blocks of your node as a second param.\n// Surrounding peers are defined in the third param.\nmc, p2p, db := initializeTestServices(t, []uint64{}, []*peerData{})\n")),(0,r.kt)("p",null,"See, ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue_test.go#L134"},"TestBlocksQueue_Loop()")," as an example of testing block syncing as a whole."),(0,r.kt)("p",null,"If you need more control on node\u2019s known state, or on peer\u2019s known state, we also have the following helper methods for that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// Setup database:\nbeaconDB := dbtest.SetupDB(t)\n// Setup network layer:\np2p := p2pt.NewTestP2P(t)\n// Setup Agora chain sequence (128 blocks):\nchain := extendBlockSequence(t, []*eth.SignedBeaconBlock{}, 128)\ngenesisBlock := chain[0]\nrequire.NoError(t, beaconDB.SaveBlock(context.Background(), genesisBlock))\ngenesisRoot, err := genesisBlock.Block.HashTreeRoot()\nrequire.NoError(t, err)\n// Initialize beacon state:\nst := testutil.NewBeaconState()\nmc := &mock.ChainService{\n    State: st,\n    Root:  genesisRoot[:],\n    DB:    beaconDB,\n    FinalizedCheckPoint: &eth.Checkpoint{\n        Epoch: finalizedEpoch,\n        Root:  []byte(fmt.Sprintf("finalized_root %d", finalizedEpoch)),\n    },\n}\n')),(0,r.kt)("p",null,"Now, you\u2019re able to populate node\u2019s chain with any blocks you need (including forked or skipped ones):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Populate database with blocks with part of the chain,\n// orphaned block will be added on top.\nfor _, blk := range chain[1:84] {\n    parentRoot := bytesutil.ToBytes32(blk.Block.ParentRoot)\n    // Save block only if the parent root is already in the database or cache.\n    if beaconDB.HasBlock(ctx, parentRoot) || mc.HasInitSyncBlock(parentRoot) {\n        require.NoError(t, beaconDB.SaveBlock(ctx, blk))\n        require.NoError(t, st.SetSlot(blk.Block.Slot))\n    }\n}\n")),(0,r.kt)("p",null,"Finally, time to configure peer\u2019s blocks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"finalizedSlot := uint64(82)\nfinalizedEpoch := helpers.SlotToEpoch(finalizedSlot)\n// Connect peer that has all the blocks available. You can have a peer with\n// forked or missed blocks -- just update the chain param.\nallBlocksPeer := connectPeerHavingBlocks(t, p2p, chain, finalizedSlot, p2p.Peers())\ndefer func() {\n    p2p.Peers().SetConnectionState(allBlocksPeer, peers.PeerDisconnected)\n}()\n")),(0,r.kt)("p",null,"Since we have prepared (and customized) all the necessary mocks, time to setup queue and fetcher services:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Setup fetcher:\nfetcher := newBlocksFetcher(\n    ctx,\n    &blocksFetcherConfig{\n        chain: mc,\n        p2p:   p2p,\n        db:    beaconDB,\n    },\n)\nfetcher.rateLimiter = leakybucket.NewCollector(6400, 6400, false)\n// Queue should be able to fetch the whole chain.\nqueue := newBlocksQueue(ctx, &blocksQueueConfig{\n    blocksFetcher:       fetcher,\n    chain:               mc,\n    highestExpectedSlot: uint64(len(chain) - 1),\n    mode:                modeNonConstrained,\n})\n")),(0,r.kt)("p",null,"For even better illustration on customized setups, please, see the following tests:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue_test.go#L134"},"TestBlocksQueue_stuckWhenHeadIsSetToOrphanedBlock()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/zeroone-boa/agora-cl/blob/ce397ce797c33dbcf77fa7670c356844ef6aad43/beacon-chain/sync/initial-sync/blocks_queue_test.go#L1026"},"TestBlocksQueue_stuckInUnfavourableFork()"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Runtime testing and usage")),(0,r.kt)("p",null,"To run unit tests using bazel:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bazel test //beacon-chain/sync/initial-sync:go_default_test --test_arg=-test.v --test_output=streamed --test_arg=-test.failfast --nocache_test_results --test_filter=\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"--test_filter")," can be empty (all tests will then be run), or specify a pattern to match:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"--test_filter"),(0,r.kt)("th",{parentName:"tr",align:null},"Component to be tested"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TestBlocksQueue"),(0,r.kt)("td",{parentName:"tr",align:null},"All blocks queue tests.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TestBlocksFetcher"),(0,r.kt)("td",{parentName:"tr",align:null},"All blocks fetcher tests.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TestStateMachine"),(0,r.kt)("td",{parentName:"tr",align:null},"All FSM related tests.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"TestService"),(0,r.kt)("td",{parentName:"tr",align:null},"All init-sync service tests.")))),(0,r.kt)("p",null,"To run tests using vanilla Go, just use ",(0,r.kt)("inlineCode",{parentName:"p"},"go test")," (to understand the reasons for passing the ",(0,r.kt)("inlineCode",{parentName:"p"},"develop")," tag see our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/DEPENDENCIES.md#running-tests"},"DEPENDENCIES"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"go test ./beacon-chain/sync/initial-sync -v -failfast -tags develop -run TestBlocksQueue\n")),(0,r.kt)("p",null,"When it comes to system and integration testing, generally one is expected to do it manually: run the Agora node and see whether it was able to sync from genesis to the latest head."),(0,r.kt)("p",null,"Variations include: stopping and restarting, stopping for a long time and then restarting, switching off access to the internet etc etc. Here is one way to do it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"# Remove previous data:\nrm -r ~/agora-cl/beaconchaindata ~/agora-cl/network-keys\n# Assuming you have geth node running locally, run init-sync on testnet\nbazel run //beacon-chain -- --datadir=$HOME/agora-cl  \\\n  --verbosity=debug \\\n  --p2p-max-peers=500 \\\n  --execution-endpoint=$HOME/Library/Ethereum/testnet/geth.ipc \\\n  --enable-debug-rpc-endpoints --testnet\n")),(0,r.kt)(s.M,{mdxType:"RequestUpdateWidget"}))}m.isMDXComponent=!0},6010:(e,t,n)=>{function a(e){var t,n,o="";if("string"==typeof e||"number"==typeof e)o+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(n=a(e[t]))&&(o&&(o+=" "),o+=n);else for(t in e)e[t]&&(o&&(o+=" "),o+=t);return o}function o(){for(var e,t,n=0,o="";n<arguments.length;)(e=arguments[n++])&&(t=a(e))&&(o&&(o+=" "),o+=t);return o}n.d(t,{Z:()=>o})},7051:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/fsm-state-trans-f1240ebbeea271147b7babb1be082be4.png"},5622:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/service-diagram-49915f4242c300f1598ccce3a652b332.png"}}]);