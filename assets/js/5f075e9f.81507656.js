"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[697],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),p=d(n),h=o,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=p;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var d=2;d<i;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1262:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),o=n(2263);const i=function(e){var t=e.children,n=e.fallback;return(0,o.Z)().isClient&&null!=t?a.createElement(a.Fragment,null,t()):n||null}},5505:(e,t,n)=>{n.d(t,{M:()=>i});var a=n(7294),o=n(1262),i=function(e){var t=e.commaDelimitedContributors,n=e.lastVerifiedDateString,i=e.lastVerifiedVersionString,s={Chris:"hewison-chris"},r=function(e){return a.createElement("a",{class:"header-badge",href:"https://github.com/"+s[e]},a.createElement("span",{class:"badge-avatar",style:{backgroundImage:"url('https://avatars.githubusercontent.com/"+s[e]+"')"}}),a.createElement("span",{class:"badge-label"},e))};return a.createElement(o.Z,null,(function(){return a.createElement("div",{class:"header-badges"},null!=t?t.split(",").map(r):null,function(e,t){if(null!=e&&null!=t)return a.createElement("a",{class:"header-badge"},a.createElement("span",{class:"badge-avatar emoji-avatar"},"\u2714\ufe0f"),a.createElement("span",{class:"badge-label"},"Last verified on ",a.createElement("strong",null,e)," using Agora-cl ",t))}(n,i),a.createElement("a",{class:"header-badge",href:"https://github.com/Bosagora/documentation/issues/new?title=Docs update request: "+new URL(window.location.href).pathname+"&body=Source: "+window.location.href+"%0A%0ARequest: (how can we help?)"},a.createElement("span",{class:"badge-avatar emoji-avatar"},"\u270f\ufe0f"),a.createElement("span",{class:"badge-label"},"Request an update")))}))}},1144:(e,t,n)=>{n.d(t,{M:()=>i});var a=n(7294),o=n(1262),i=function(e){return function(e){if(null==e)throw new TypeError("Cannot destructure undefined")}(e),a.createElement(o.Z,null,(function(){return a.createElement("div",{class:"update-request"},a.createElement("a",{href:"https://https://github.com/zeroone-boa/agora-cl-docs/issues/new?title=Docs update request: "+new URL(window.location.href).pathname+"&body=Source: "+window.location.href+"%0A%0ARequest: (how can we help?)"},"\ud83d\udc3c Request an update"))}))}},7103:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>c,default:()=>m,frontMatter:()=>d,metadata:()=>u,toc:()=>p});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),s=n(5505),r=n(1144),l=["components"],d={id:"end-to-end",title:"End-to-end tests",sidebar_label:"End-to-end tests"},c=void 0,u={unversionedId:"devtools/end-to-end",id:"devtools/end-to-end",isDocsHomePage:!1,title:"End-to-end tests",description:"Even the best unit tests won't prevent bugs from creeping into the system. They test small pieces of code in isolation, but it might be the interaction between different modules/packages/subsystems that causes issues. Agora-cl consist of two separate components, the Agora chain and the validator, that interact with each other in non-trivial ways. Additionally, the system contacts an Eth1 endpoint to access various information about the Eth1 chain. It is therefore very important to find integration bugs as soon as possible. The way Agora-cl achieves this is through having an E2E (end-to-end) test module. Tests inside this module are ran on every PR build, which greatly increases confidence that new code can safely be merged.",source:"@site/docs/devtools/end-to-end.md",sourceDirName:"devtools",slug:"/devtools/end-to-end",permalink:"/docs/devtools/end-to-end",editUrl:"https://github.com/zeroone-boa/agora-cl-docs/edit/master/website/docs/devtools/end-to-end.md",version:"current",frontMatter:{id:"end-to-end",title:"End-to-end tests",sidebar_label:"End-to-end tests"},sidebar:"docs",previous:{title:"BLS cryptography",permalink:"/docs/how-agora-cl-works/bls-cryptography"},next:{title:"Security audits",permalink:"/docs/audits/phase0"}},p=[{value:"Running E2E tests",id:"running-e2e-tests",children:[]},{value:"How are E2E tests special?",id:"how-are-e2e-tests-special",children:[]},{value:"E2E building blocks",id:"e2e-building-blocks",children:[{value:"Components",id:"components",children:[]},{value:"Evaluators",id:"evaluators",children:[]},{value:"Policies",id:"policies",children:[]}]},{value:"Investigating failures",id:"investigating-failures",children:[]},{value:"Testing features",id:"testing-features",children:[]}],h={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s.M,{mdxType:"HeaderBadgesWidget"}),(0,i.kt)("p",null,"Even the best unit tests won't prevent bugs from creeping into the system. They test small pieces of code in isolation, but it might be the interaction between different modules/packages/subsystems that causes issues. Agora-cl consist of two separate components, the Agora chain and the validator, that interact with each other in non-trivial ways. Additionally, the system contacts an Eth1 endpoint to access various information about the Eth1 chain. It is therefore very important to find integration bugs as soon as possible. The way Agora-cl achieves this is through having an E2E (end-to-end) test module. Tests inside this module are ran on every PR build, which greatly increases confidence that new code can safely be merged."),(0,i.kt)("h2",{id:"running-e2e-tests"},"Running E2E tests"),(0,i.kt)("p",null,"The below command will run E2E tests using the minimal E2E configuration. It will run for 10 epochs. We additionally specify a timeout value and declare ",(0,i.kt)("inlineCode",{parentName:"p"},"--test_output=streamed")," to output logs for all tests in real time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"bazel test //testing/endtoend:go_default_test --//proto:network=minimal --test_filter=TestEndToEnd_MinimalConfig --test_env=E2E_EPOCHS=10 --test_timeout=10000 --test_output=streamed\n")),(0,i.kt)("h2",{id:"how-are-e2e-tests-special"},"How are E2E tests special?"),(0,i.kt)("p",null,"E2E tests are located in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend"},"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend"),". They are regular Go tests enhanced by Bazel. The main reason why we need Bazel is to prepare binaries for components executed by the test, including the Agora node and validator. This means we are testing the system as a whole, including all inter-process communication. E2E uses a dedicated beacon config that overrides several important parameters, such as time-related values (we don't want the test to take too long given that it's supposed to run for several epochs)."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"TestEndToEnd_MinimalConfig")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"TestEndToEnd_MinimalConfig_ValidatorAtCurrentRelease")," is that the former runs the latest validator code, whereas the latter run the validator's latest release. The idea is to ensure backwards compatibility between ",(0,i.kt)("inlineCode",{parentName:"p"},"HEAD")," and the latest validator release."))),(0,i.kt)("h2",{id:"e2e-building-blocks"},"E2E building blocks"),(0,i.kt)("p",null,"There are three main building block types from which E2E tests are constructed: components, evaluators and policies."),(0,i.kt)("h3",{id:"components"},"Components"),(0,i.kt)("p",null,"An E2E component is an abstract concept that represents a service that can be started and whose status can be inspected. It is defined as a Go interface type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// ComponentRunner defines an interface via which E2E component's configuration, execution and termination is managed.\ntype ComponentRunner interface {\n    // Start starts a component.\n    Start(ctx context.Context) error\n    // Started checks whether an underlying component is started and ready to be queried.\n    Started() <-chan struct{}\n}\n")),(0,i.kt)("p",null,"There are several types that implement this interface and they can all be found in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend/components"},"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend/components"),"."),(0,i.kt)("p",null,"E2E requires appropriate regular version updates for certain components that run on binary such as web3signer. Currently, E2E can only support 1 version of a component at a time."),(0,i.kt)("p",null,"Running components correctly is not a simple task. We can't simply start up all components at the same time and expect the system to work. The Agora node requires a running boot node to be able to find peers, as well as an Eth1 node with blocks that include deposits for validators that will be used during the test. This means we need a combination of synchronous and asynchronous behavior. This is achieved by the use of goroutines and the ",(0,i.kt)("inlineCode",{parentName:"p"},"ComponentRunner")," interface inside ",(0,i.kt)("inlineCode",{parentName:"p"},"run()")," in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/testing/endtoend/endtoend_test.go"},"https://github.com/zeroone-boa/agora-cl/blob/develop/testing/endtoend/endtoend_test.go"),"."),(0,i.kt)("h3",{id:"evaluators"},"Evaluators"),(0,i.kt)("p",null,"An E2E evaluator is a type defined as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"// Evaluator defines the structure of the evaluators used to conduct the current beacon state during the E2E.\ntype Evaluator struct {\n    Name       string\n    Policy     func(currentEpoch types.Epoch) bool\n    Evaluation func(conn ...*grpc.ClientConn) error // A variable amount of conns is allowed to be passed in for evaluations to check all nodes if needed.\n}\n")),(0,i.kt)("p",null,"The purpose of an evaluator is to assert an invariant that the system must hold in order to run properly. Examples of such invariants include the ability to undergo a fork transition or the ability to find peers in the network. All evaluators can be found in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend/evaluators"},"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend/evaluators"),"."),(0,i.kt)("p",null,"Each evaluator has a name, a policy (which we will cover later) and an evaluation function. The evaluation function is the actual code that asserts if the system behaves correctly. If the invariant is broken, an error is returned from the function, and the test is stopped and considered failed."),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Evaluators are executed at the beginning of an epoch."),(0,i.kt)("li",{parentName:"ul"},"The list of evaluators to run is specified by each test separately.")))),(0,i.kt)("h3",{id:"policies"},"Policies"),(0,i.kt)("p",null,"Not every invariant can be checked at every epoch. As an example, the Altair fork transition invariant should be asserted only after the Altair hard fork occurred. Evaluator timings are controlled with policies, which are simple functions returning boolean values, with ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," indicating that the evaluator should be ran for a specific epoch. All policies can be found in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend/policies"},"https://github.com/zeroone-boa/agora-cl/tree/develop/testing/endtoend/policies"),"."),(0,i.kt)("h2",{id:"investigating-failures"},"Investigating failures"),(0,i.kt)("p",null,"If one or more evaluators fail, we get a console output similar to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"--- FAIL: TestEndToEnd_MinimalConfig (234.18s)\n    --- PASS: TestEndToEnd_MinimalConfig/chain_started (14.50s)\n    --- PASS: TestEndToEnd_MinimalConfig/finished_syncing_0 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/validators_active_epoch_0 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/peers_connect_epoch_0 (0.10s)\n    --- PASS: TestEndToEnd_MinimalConfig/all_nodes_have_same_head_0 (0.10s)\n    --- FAIL: TestEndToEnd_MinimalConfig/healthz_check_epoch_1 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/finished_syncing_1 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/validators_active_epoch_1 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/peers_check_epoch_1 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/verify_graffiti_in_blocks_epoch_1 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/validators_vote_with_the_majority_1 (0.00s)\n    --- PASS: TestEndToEnd_MinimalConfig/all_nodes_have_same_head_1 (0.10s)\n    --- PASS: TestEndToEnd_MinimalConfig/metrics_check_epoch_1 (0.11s)\nFAIL\nFAIL: //testing/endtoend:go_default_test (see /home/user/.cache/bazel/_bazel_user/ec3daeb6ce0cd7052bf7c79ca31f19c6/execroot/agora-cl/bazel-out/k8-fastbuild-ST-02d640e6fd05/testlogs/testing/endtoend/go_default_test/test.log)\nTarget //testing/endtoend:go_default_test up-to-date:\n  bazel-out/k8-fastbuild-ST-02d640e6fd05/bin/testing/endtoend/go_default_test_/go_default_test\nINFO: Elapsed time: 235.338s, Critical Path: 235.16s\nINFO: 2 processes: 1 internal, 1 linux-sandbox.\nINFO: Build completed, 1 test FAILED, 2 total actions\n//testing/endtoend:go_default_test                                       FAILED in 235.1s\n  /home/user/.cache/bazel/_bazel_user/ec3daeb6ce0cd7052bf7c79ca31f19c6/execroot/agora-cl/bazel-out/k8-fastbuild-ST-02d640e6fd05/testlogs/testing/endtoend/go_default_test/test.log\n\nINFO: Build completed, 1 test FAILED, 2 total actions\n")),(0,i.kt)("p",null,"This tells us which evaluator failed (",(0,i.kt)("inlineCode",{parentName:"p"},"healthz_check_epoch_1"),"), but we don't know the reason of the failure. Fortunately, there are several logs that we can inspect. First of all, we can take a look at the main test log, whose path is provided in the output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"/home/user/.cache/bazel/_bazel_user/ec3daeb6ce0cd7052bf7c79ca31f19c6/execroot/agora-cl/bazel-out/k8-fastbuild-ST-02d640e6fd05/testlogs/testing/endtoend/go_default_test/test.log\n")),(0,i.kt)("p",null,"The directory of the ",(0,i.kt)("inlineCode",{parentName:"p"},"test.log")," file contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"test.output")," directory, which itself contains a zipped file with logs from several components, including all beacon nodes and validator clients started up during the test. They provide invaluable information about our test run. As an example, let's inspect a different error message:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"endtoend_test.go:279: E2E test ended in error: failed to start the ETH1 miner: exit status 1\n")),(0,i.kt)("p",null,"The uzipped output file contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"eth1-init_miner.log")," file with the following contents:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Fatal: Failed to read genesis file: open /home/user/.cache/bazel/","_","bazel","_","user/ec3daeb6ce0cd7052bf7c79ca31f19c6/sandbox/linux-sandbox/1779/execroot/agora-cl/bazel-out/k8-fastbuild-ST-02d640e6fd05/bin/testing/endtoend/go","_","default","_","test","_","/go","_","default","_","test.runfiles/com","_","github","_","ethereum","_","go","_","ethereum/cmd/geth/geth_/genesiss.json: no such file or directory")),(0,i.kt)("p",null,"The issue here is that our repo contains a static file named ",(0,i.kt)("inlineCode",{parentName:"p"},"genesis.json")," that we want to use to initialize Geth, but issuing the command has a typo in the word ",(0,i.kt)("inlineCode",{parentName:"p"},"genesis")," (there is a double ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," at the end)."),(0,i.kt)("h2",{id:"testing-features"},"Testing features"),(0,i.kt)("p",null,"Agora-cl supports ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/config/features/README.md"},"feature flags"),", which are very useful when we want to test a particular feature before making it a standard in production. Sometimes you might want to run E2E with your feature flag enabled. To do this, go to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/develop/config/features/flags.go"},"https://github.com/zeroone-boa/agora-cl/blob/develop/config/features/flags.go")," and append your flag to ",(0,i.kt)("inlineCode",{parentName:"p"},"E2EBeaconChainFlags"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'var E2EBeaconChainFlags = []string{\n    "--dev",\n    "--my-feature",\n}\n')),(0,i.kt)(r.M,{mdxType:"RequestUpdateWidget"}))}m.isMDXComponent=!0}}]);