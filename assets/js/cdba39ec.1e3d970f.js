"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4807],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=c(a),h=o,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||i;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,s=new Array(i);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1262:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(7294),o=a(2263);const i=function(e){var t=e.children,a=e.fallback;return(0,o.Z)().isClient&&null!=t?n.createElement(n.Fragment,null,t()):a||null}},5505:(e,t,a)=>{a.d(t,{M:()=>i});var n=a(7294),o=a(1262),i=function(e){var t=e.commaDelimitedContributors,a=e.lastVerifiedDateString,i=e.lastVerifiedVersionString,s={Chris:"hewison-chris"},r=function(e){return n.createElement("a",{class:"header-badge",href:"https://github.com/"+s[e]},n.createElement("span",{class:"badge-avatar",style:{backgroundImage:"url('https://avatars.githubusercontent.com/"+s[e]+"')"}}),n.createElement("span",{class:"badge-label"},e))};return n.createElement(o.Z,null,(function(){return n.createElement("div",{class:"header-badges"},null!=t?t.split(",").map(r):null,function(e,t){if(null!=e&&null!=t)return n.createElement("a",{class:"header-badge"},n.createElement("span",{class:"badge-avatar emoji-avatar"},"\u2714\ufe0f"),n.createElement("span",{class:"badge-label"},"Last verified on ",n.createElement("strong",null,e)," using Agora-cl ",t))}(a,i),n.createElement("a",{class:"header-badge",href:"https://github.com/Bosagora/documentation/issues/new?title=Docs update request: "+new URL(window.location.href).pathname+"&body=Source: "+window.location.href+"%0A%0ARequest: (how can we help?)"},n.createElement("span",{class:"badge-avatar emoji-avatar"},"\u270f\ufe0f"),n.createElement("span",{class:"badge-label"},"Request an update")))}))}},9435:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>p,toc:()=>d});var n=a(7462),o=a(3366),i=(a(7294),a(3905)),s=a(5505),r=["components"],l={id:"testnet-postmortems",title:"Testnet postmortems",sidebar_label:"Testnet postmortems"},c=void 0,p={unversionedId:"reading/testnet-postmortems",id:"reading/testnet-postmortems",isDocsHomePage:!1,title:"Testnet postmortems",description:"Testnet Incident Reports",source:"@site/docs/reading/testnet_postmortems.md",sourceDirName:"reading",slug:"/reading/testnet-postmortems",permalink:"/docs/reading/testnet-postmortems",editUrl:"https://github.com/zeroone-boa/agora-cl-docs/edit/master/website/docs/reading/testnet_postmortems.md",version:"current",frontMatter:{id:"testnet-postmortems",title:"Testnet postmortems",sidebar_label:"Testnet postmortems"},sidebar:"docs",previous:{title:"Agora readings",permalink:"/docs/reading/eth2"},next:{title:"Block explorers",permalink:"/docs/devtools/block-explorers"}},d=[{value:"Testnet Incident Reports",id:"testnet-incident-reports",children:[{value:"Not Receiving P2P Blocks (Incident #7)",id:"not-receiving-p2p-blocks-incident-7",children:[]},{value:"Chain Stuck at Genesis (Incident #6)",id:"chain-stuck-at-genesis-incident-6",children:[]},{value:"Rapid P2P Message Drop (Incident #5)",id:"rapid-p2p-message-drop-incident-5",children:[]},{value:"Mutex Deadlock Cascading Failures (Incident #4)",id:"mutex-deadlock-cascading-failures-incident-4",children:[]},{value:"Finality Decreased! (Incident #3)",id:"finality-decreased-incident-3",children:[]},{value:"Goerli / PoW Nodes Offline Killed Testnet (Incident #2)",id:"goerli--pow-nodes-offline-killed-testnet-incident-2",children:[]},{value:"Testnet Large Finality Gap Postmortem (Incident #1)",id:"testnet-large-finality-gap-postmortem-incident-1",children:[]}]}],u={toc:d};function h(e){var t=e.components,a=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s.M,{mdxType:"HeaderBadgesWidget"}),(0,i.kt)("h2",{id:"testnet-incident-reports"},"Testnet Incident Reports"),(0,i.kt)("p",null,"As part of our day to day job in building eth2 with our Agora-cl project, we are tasked with maintaining a high integrity cloud deployment that runs several nodes in our testnet. Additionally, we are always on call to determine problems which arise in the network and must be addressed by the team. This page outlines a collection of incident reports and their resolutions from catastrophic events in our testnet. We hope it will shed more light on our devops process and how we tackle the hard problems managing a distributed system such as eth2 entails."),(0,i.kt)("h3",{id:"not-receiving-p2p-blocks-incident-7"},"Not Receiving P2P Blocks (Incident #7)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 2020/04/18"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Preston, Raul"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Root cause identified, resolved"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Network:")," Topaz"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," Beacon nodes were not receiving blocks via gossipsub p2p at all, making it impossible to keep up with the chain head after initial sync completes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Reference issues:"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/5476"},"https://github.com/zeroone-boa/agora-cl/issues/5476"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/5491"},"https://github.com/zeroone-boa/agora-cl/issues/5491")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," This incident was reproducible on most node restarts, making it likely to kill our testnet if left unchecked."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," There was a race condition from the sync service needing access to the genesis time to compute a fork digest for subscribing to gossipsub topics. This value is set in the p2p service, but sometimes sync would begin before the p2p service, leading it to have a genesis time of 0."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," Performing Agora node restarts could easily reproduce this issue."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," We resolve the race condition by not making sync rely on p2p to set its ForkDigest, but instead get the genesis time directly from the blockchain service and refactoring ForkDigest to be a pure stateless function."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," Local runs, user reports."),(0,i.kt)("h4",{id:"where-we-got-lucky"},"Where we got lucky"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Our pods haven\u2019t had any rolling restarts or canaries rolling out that would trigger this issue, which is reproducible many times upon starting a Agora node. If our pods restarted, our testnet could have likely been killed and have had multiple forks.")),(0,i.kt)("h4",{id:"root-cause"},"Root Cause"),(0,i.kt)("p",null,"Regular sync topic subscription was using a ",(0,i.kt)("inlineCode",{parentName:"p"},"forkDigest")," of zero due to a race condition where the p2p service\u2019s genesis time and genesis validator root was not yet initialized."),(0,i.kt)("p",null,"Preston realized he would see weird subscribed topics in his local node\u2019s p2p metrics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'p2p_topic_peer_count{topic="/eth2/00000000/attester_slashing/ssz_snappy"} 0\np2p_topic_peer_count{topic="/eth2/00000000/beacon_aggregate_and_proof/ssz_snappy"} 0\np2p_topic_peer_count{topic="/eth2/00000000/beacon_block/ssz_snappy"} 0\np2p_topic_peer_count{topic="/eth2/00000000/proposer_slashing/ssz_snappy"} 0\np2p_topic_peer_count{topic="/eth2/00000000/voluntary_exit/ssz_snappy"} 0\np2p_topic_peer_count{topic="/eth2/f071c66c/attester_slashing/ssz_snappy"} 3\np2p_topic_peer_count{topic="/eth2/f071c66c/beacon_aggregate_and_proof/ssz_snappy"} 3\np2p_topic_peer_count{topic="/eth2/f071c66c/beacon_block/ssz_snappy"} 2\np2p_topic_peer_count{topic="/eth2/f071c66c/proposer_slashing/ssz_snappy"} 3\np2p_topic_peer_count{topic="/eth2/f071c66c/voluntary_exit/ssz_snappy"} 3\n')),(0,i.kt)("p",null,"Showing duplicate values for various topics, where the 00000000 and f071c66c are the fork digests for the node. The 0 value was problematic, likely showing the sync service was started with a genesis time of 0. Preston then identified:"),(0,i.kt)("h4",{id:"timeline"},"Timeline"),(0,i.kt)("p",null,"2020-04-16 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"02:00:00 Terence reports his nodes are not getting blocks via the gossip network in local chain testing, he mentions it doesn\u2019t occur all the time and we put the issue on the backburner.")),(0,i.kt)("p",null,"2020-04-18 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"08:02:00 Preston mentions he observes fork ENR mismatches in peer connections, Raul dismisses it as likely just a bootnode failure, and Preston also observes his local node isn\u2019t receiving any blocks via gossip sub p2p"),(0,i.kt)("li",{parentName:"ul"},"22:16:00 Preston tries to discover a potential race condition by making the p2p.ForkDigest() function return an error if p2p.genesisTime is not set, which ended up panicking right away, giving us a clue"),(0,i.kt)("li",{parentName:"ul"},"22:30:00 Raul mentions there are two places where the state initialized feed fires, and they are not likely to have bugs. This feed is what notifies other services in Agora-cl of the genesis time and the genesis validators root, two critical values to compute a small hex digest used for subscribing to gossipsub topics."),(0,i.kt)("li",{parentName:"ul"},"22:33:00 Preston confirms the sync genesis time value is set to 0, and that we are likely subscribing to wrong gossip topics"),(0,i.kt)("li",{parentName:"ul"},"22:35:00 Nishant mentions: \u201cso sync needs to wait after p2p is initialized seems like sync and p2p start at the same time which is our main problem\u201d"),(0,i.kt)("li",{parentName:"ul"},"22:36:00 Preston reports the ForkDigest method does not need to be a pointer receiver of the p2p service, but can instead be a pure helper function that services can fill in with canonical values from the blockchain service, preventing any potential race conditions"),(0,i.kt)("li",{parentName:"ul"},'22:39:00 Preston reports the issue is now resolved in his local node after seeing the beacon block p2p received metrics go up p2p_message_received_total{topic="/eth2/f071c66c/beacon_block/ssz_snappy"} 19')),(0,i.kt)("h3",{id:"chain-stuck-at-genesis-incident-6"},"Chain Stuck at Genesis (Incident #6)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 2019/01/09"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Raul, Terence, Preston"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Solved - root cause identified: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/4526#issuecomment-573828747"},"https://github.com/zeroone-boa/agora-cl/issues/4526#issuecomment-573828747")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," No one was able to propose a block after genesis time was reached with the mainnet config in our running testnet, required manual intervention."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," 216 skip slots after genesis. Over 30 minutes of downtime."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," Genesis block has a state root that does not match the genesis state. Still investigating other root causes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," Genesis time was reached."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," Use database headBlock rather than cached head block with a fresh database. PR 4473 was deployed as a hotfix in production."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," DevOps observation, alerts, user reports."),(0,i.kt)("h4",{id:"where-we-got-lucky-1"},"Where we got lucky"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Minio took a backup exactly at genesis time, so we have a backup copy of the problem beacondb.")),(0,i.kt)("h4",{id:"root-cause-1"},"Root Cause"),(0,i.kt)("p",null,"The problem had to do with usage of both ",(0,i.kt)("inlineCode",{parentName:"p"},"go-ssz.HashTreeRoot")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"stateutil.HashTreeRootState")," in Agora-cl for the genesis state. Explanation outlined here: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/issues/4526#issuecomment-573828747"},"https://github.com/zeroone-boa/agora-cl/issues/4526#issuecomment-573828747")),(0,i.kt)("h4",{id:"timeline-1"},"Timeline"),(0,i.kt)("p",null,"2019-01-09 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"8 prod nodes are online several hours before genesis time.")),(0,i.kt)("p",null,"2019-01-10"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"00:00:00 Genesis time was reached."),(0,i.kt)("li",{parentName:"ul"},"00:00:00 Minio backup occurs. Link"),(0,i.kt)("li",{parentName:"ul"},"00:00:16 Slot 1 passed, no block produced."),(0,i.kt)("li",{parentName:"ul"},'00:04:00 Preston observes logs that fail GetBlock RPC across all validators. "Could not compute state root: could not calculate state root at slot 0: could not process block: could not process block header: parent root 0x0e6c95db700881611523e282ec3fcaeeace681786aa47928c5903650165c6165 does not match the latest block header signing root in state 0x8b25301bdeba020d4226e949eae0ecefb8863e060b7844566d51e0a42ed6490e"'),(0,i.kt)("li",{parentName:"ul"},"00:08:00 Preston restarts prod-7 and shifts all traffic there. The idea was to clear any cache value that existed before genesis start. This attempt was unsuccessful at resolving the issue."),(0,i.kt)("li",{parentName:"ul"},"00:15:00 All hands on deck called."),(0,i.kt)("li",{parentName:"ul"},"00:21:00 Preston deploys a hotfix. (See supporting info)"),(0,i.kt)("li",{parentName:"ul"},"00:31:00 Preston shifts all traffic to prod-7, which has the hotfix. This attempt is unsuccessful."),(0,i.kt)("li",{parentName:"ul"},"00:33:00 Preston wipes the DB of prod-6 and restarts prod-6."),(0,i.kt)("li",{parentName:"ul"},"00:43:00 Preston shifts all traffic to prod-6. Blocks are starting to be produced."),(0,i.kt)("li",{parentName:"ul"},"00:46:00 Preston wipes all other prod databases and restarts. Prod-6 still only one serving traffic."),(0,i.kt)("li",{parentName:"ul"},"00:48:00 Ivan communicates to users to wipe their database and restart their nodes to sync."),(0,i.kt)("li",{parentName:"ul"},"00:55:00 Nodes cannot sync with --init-sync-state-cache, a nil state is attempted to be saved in the database."),(0,i.kt)("li",{parentName:"ul"},"00:58:00 Finality is reached."),(0,i.kt)("li",{parentName:"ul"},"01:10:00 Preston scales prod nodes to 10 and reverts the problem flag. This is to prevent prod-6 from getting killed if prod-7 reports healthy prematurely."),(0,i.kt)("li",{parentName:"ul"},"01:20:00 Preston unshifts traffic from prod-6. All healthy prod pods are serving traffic now with high gRPC success rate."),(0,i.kt)("li",{parentName:"ul"},"16:18:00 Preston inspects the backup database to observe that the genesis state was equal to a genesis state from running prod pod."),(0,i.kt)("li",{parentName:"ul"},"16:29:00 Preston inspects the backup database to observe that the genesis block state root does not match the genesis state. In the problem database, genesis block state root is 0x5a45fd74d5359fb113ec5eaa8614b652aa4ef13493b1ff9439ac7bdadaed224a and genesis state root is 0x710178cf469dcd70bb1c97630205399d26e8f0913659bb591ec9c0c1ab734f1e and the hash tree root of the problem genesis block is 0x0e6c95db700881611523e282ec3fcaeeace681786aa47928c5903650165c6165."),(0,i.kt)("li",{parentName:"ul"},"17:10:00 After further investigation between a healthy DB and one that was in the incident, Raul finds the genesis states in the DB match, but the genesis blocks mismatch due to state root problems. This is scary as it does not make much sense with our codebase.")),(0,i.kt)("h4",{id:"supporting-information"},"Supporting information"),(0,i.kt)("p",null,"The hotfix that was applied:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"diff --git a/beacon-chain/rpc/validator/proposer.go b/beacon-chain/rpc/validator/proposer.go\nindex 220e7efd5..46092bd73 100644\n--- a/beacon-chain/rpc/validator/proposer.go\n+++ b/beacon-chain/rpc/validator/proposer.go\n@@ -36,7 +36,11 @@ func (vs *Server) GetBlock(ctx context.Context, req *ethpb.BlockRequest) (*ethpb\n        }\n\n        // Retrieve the parent block as the current head of the canonical chain.\n-       parent := vs.HeadFetcher.HeadBlock()\n+//     parent := vs.HeadFetcher.HeadBlock()\n+       parent, err := vs.BeaconDB.HeadBlock(ctx)\n+       if err != nil {\n+               return nil, err\n+       }\n\n        parentRoot, err := ssz.HashTreeRoot(parent.Block)\n        if err != nil {\n")),(0,i.kt)("h3",{id:"rapid-p2p-message-drop-incident-5"},"Rapid P2P Message Drop (Incident #5)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 26/11/2019"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Nishant"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Root Cause Under Investigation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," We had a rapid drop in p2p message rates, which consequently lead to a long period without finality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," Due to a sudden drop in p2p message rates, especially for attestations this lead to a long period without finality. The majority of our production pods ended up getting stuck and we started receiving large grpc failure rates."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," Yet To Be Determined"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," Yet to Be Determined"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," This was finally resolved when we scaled down our relay nodes and restarted all our out of sync production pods. The p2p message rate for attestations finally increased back to their normal levels and we got justification and finality soon after."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," Pinged in discord when time since last finalized epoch was greater than 10."),(0,i.kt)("h4",{id:"lessons-learned"},"Lessons Learned"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went wrong"),"\nThere wasn\u2019t an obvious trigger that we were able to inspect. All the major metrics and charts were fine, so it seemed from the outset that the chain was working normally as expected. However investigating the p2p message count showed another picture not captured by our current metrics and alerts."),(0,i.kt)("h4",{id:"where-we-got-lucky-2"},"Where we got lucky"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Blocks were still being produced, so that allowed us to recover the chain even though we were 5 hours out from finality.")),(0,i.kt)("h4",{id:"timeline-2"},"Timeline"),(0,i.kt)("p",null,"2019-01-01 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"04:50 Nishant notices a ping on discord indicating that it has been more than 10 epochs since finality. Looking at the grafana charts, it seemed normal, so Nishant ignored it thinking it would resolve by itself."),(0,i.kt)("li",{parentName:"ul"},"05:00 Nishant again looks at the grafana charts but notices that there hasn\u2019t been justification or finality for 15 mins. However all other metrics and charts are normal and there isn\u2019t a directly obvious explanation for it."),(0,i.kt)("li",{parentName:"ul"},"05:05 Nishant notices that the p2p message count has dropped by a very large amount, which explains the long period without finality in the current chain. With very little attestations being sent over the wire, we have a large drop in participation rates and therefore a drop in justification and finality."),(0,i.kt)("li",{parentName:"ul"},"05:37 Nishant tries to rollout the current master image to all production pods."),(0,i.kt)("li",{parentName:"ul"},"05:50 The rollout does not bring any tangible results, with there being no justifcation or finality still. At this point it has been more than 50 epochs since finality."),(0,i.kt)("li",{parentName:"ul"},"07:30 Now high grpc failure rates happen across all pods. At this moment it has been more than a 100 epochs since finality. Due to that this brings a lot of stress on the agora-cl node with regards to forkchoice when determining the current head."),(0,i.kt)("li",{parentName:"ul"},"07:40 Nishant now reverts the connection manager fix and tries to roll the old image out to the experimental pods."),(0,i.kt)("li",{parentName:"ul"},"08:30 The fix however, takes a very long time to rollout due to the slow sync, which displays 2 hours to sync till the current chain head. Nishant then deploys a new fix which includes a recently merged PR for faster sync processing."),(0,i.kt)("li",{parentName:"ul"},"08:50 However the fix did not have the desired effect , and now grpc failure rates climbed even higher."),(0,i.kt)("li",{parentName:"ul"},"9:40 Preston, Terence and Raul are all now online and the situation is relayed to them."),(0,i.kt)("li",{parentName:"ul"},"09:45 Preston now scales down all the relay nodes to 0 to reduce the peer counts."),(0,i.kt)("li",{parentName:"ul"},"10:00 Preston deletes the stuck production pods, to allow only synced nodes to be hosting validators."),(0,i.kt)("li",{parentName:"ul"},"10:10 Attestations Message Rate increasing now."),(0,i.kt)("li",{parentName:"ul"},"10:12 We finally get justification"),(0,i.kt)("li",{parentName:"ul"},"10:17 We get finality after 5 hours and the testnet survives for another day."),(0,i.kt)("li",{parentName:"ul"},"10:45 Now that all pods are healthy in the cluster, the relay is turned back on by Preston.")),(0,i.kt)("h3",{id:"mutex-deadlock-cascading-failures-incident-4"},"Mutex Deadlock Cascading Failures (Incident #4)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 2019/11/23"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Raul Jordan, Nishant Das"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Root cause under investigation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," A PR into Agora-cl (Add Lock When Accessing Checkpoints #4086)  including a mutex lock for reading and updated justified checkpoint values was checked-in to Agora-cl, pushed into a Canary deployment, and then rolled out into production after the Canary successfully passed. The feature led to deadlocks in requesting attestations and proposing blocks, creating a massive drop in validator participation eventually leading to many epochs since finality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," Large number of epochs since finality created lots of context deadlines being exceeded, causing gRPC success to tank, and eventually making it hard for beacon nodes to serve any traffic as it would take too long to process a block or request attestations even after the problematic feature was reverted. This led to many cascading failures when attempting to revive the stateful set pods and rollout other old images."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," Deadlock in a very frequently used mutex. Other potential root causes still under investigation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," Canary rollout into production with commit 2f392544a6586ed7a4235a4550a2ad91dfa4a60d"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," Rolled back to prior image, scaled down statefulset pods that were unable to sync and left archival+experimental pods on, eventually achieved justification and finality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," Ping on discord. gRPC success rate alerts at low-levels: ProposeBlock, RequestAttestation."),(0,i.kt)("h4",{id:"lessons-learned-1"},"Lessons Learned"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went well"),"\nWe were able to quickly come up with hypotheses as to what went wrong, we used Jaeger to notice forkchoice.OnBlock was taking an unreasonable amount of time, and identified that it was calling the function where the mutex deadlock was occurring."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went wrong"),"\nEven after reverting the bad feature causing the original problem, it took a lot of manual effort to fix the cascading failures and other side-effects of the original problem."),(0,i.kt)("h4",{id:"where-we-got-lucky-3"},"Where we got lucky"),(0,i.kt)("p",null,"We thankfully had archival and experimental pods that were working fine and as such, we were able to scale down the problematic statefulset to 0 pods and achieve justification. We got lucky our archival and experimental pods can serve traffic to validators."),(0,i.kt)("h4",{id:"timeline-3"},"Timeline"),(0,i.kt)("p",null,"2019-11-23 (all times Central Standard Time)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"03:07 - We receive an alert on discord for > 10 epochs since finality in the network"),(0,i.kt)("li",{parentName:"ul"},"03:11 - ProposeBlock gRPC success rate drops to 83%"),(0,i.kt)("li",{parentName:"ul"},"09:00 - Nishant raises issues about archival nodes being the potential offenders of the situation"),(0,i.kt)("li",{parentName:"ul"},"09:31 - Nishant suggest scaling down archival nodes to 0, Preston runs the commands"),(0,i.kt)("li",{parentName:"ul"},"09:40 - Scaling down does not work - we receive an alert in discord mentioning > 25 epochs since finality"),(0,i.kt)("li",{parentName:"ul"},"09:53 - Preston has observes very long times for spans in jaeger in proposing a block, suggesting there is some sort of mutex deadlock going on. Signatures failing on request block with the message ",(0,i.kt)("inlineCode",{parentName:"li"},"parent root does not match the latest block header signing root in state")),(0,i.kt)("li",{parentName:"ul"},"10:00 - Raul begins investigating, looking in more detail at jaeger spans to increase likeliness of lock being the root cause"),(0,i.kt)("li",{parentName:"ul"},"10:16 - Raul identifies large monitoring gap in Jaeger, with the most expensive operation in forkchoice.OnBlock not having a span. Looking at Agora-cl PR #4086 shows a function ",(0,i.kt)("inlineCode",{parentName:"li"},"updateCheckpoints")," called in forkchoice.OnBlock without a span, providing high likelihood it is the offender"),(0,i.kt)("li",{parentName:"ul"},"10:24 - Preston suggests rolling back all images to version before PR #4086, suggesting image tag: bosagora/agora-cl-node@sha256:7f9a060569d32a1ae05027ba2f0337b586b27dfd7a46307f552046271f1b448c. Raul proceeds and applies image to statefulset, archival deployment, and experimental deployment"),(0,i.kt)("li",{parentName:"ul"},"10:33 - Rollback succeeded in removing the deadlock in forkchoice.OnBlock, but grpc.ProposeBlock still failing at an alarming rate. Investigation into jaeger spans concludes ProcessSlots in the state transition function is taking too long and leading to deadline exceeded problems"),(0,i.kt)("li",{parentName:"ul"},"10:38 - Raul identifies ProcessSlots is taking an average of 5 seconds due to SSZ in the production nodes, making it nearly impossible for validators to attest or request attestations to put into blocks"),(0,i.kt)("li",{parentName:"ul"},"10:39 - Terence suggests using the emergency flag created by Nishant called --enable-skip-slots-cache in all the beacon nodes"),(0,i.kt)("li",{parentName:"ul"},"10:41 - Raul enables --enable-skip-slots-cache by applying a modified k8s manifest to the various deployments/statefulsets, observes < 1s to propose block after being applied. Cluster still does not recover."),(0,i.kt)("li",{parentName:"ul"},"10:44 - Preston notices errors for AggregateAndProof in the validator client, which means we also forgot to revert the validator client images to the previous version"),(0,i.kt)("li",{parentName:"ul"},"10:50 - No more deadline exceeded errors, but chain is not recovering. There are still problems with many nodes being stuck after initial sync and seemingly being restarted."),(0,i.kt)("li",{parentName:"ul"},"11:34 - ProposeBlock and RequestAttestation still failing, still many epochs since finality, Raul notices pods keep getting restarted and rescheduled, but apparently archival and experimental nodes are still functional and advancing our chain"),(0,i.kt)("li",{parentName:"ul"},"12:16 - Confirmed via Kibana pods finish initial sync in the statefulset but at the end have unhealthy status ",(0,i.kt)("inlineCode",{parentName:"li"},"Node is unhealthy! ERROR syncing\\n*sync.RegularSync: ERROR waiting for initial sync")),(0,i.kt)("li",{parentName:"ul"},"12:18 - Raul tracks logs for all beacon-chain-prod nodes and notices they always are unhealthy after initial sync but there are no error logs, issues persist"),(0,i.kt)("li",{parentName:"ul"},"12:30 - Nishant resumes investigation, decides to scale down statefulset prod nodes to 0"),(0,i.kt)("li",{parentName:"ul"},"12:52 - Network achieves justification"),(0,i.kt)("li",{parentName:"ul"},"12:56 - Network achieves finality"),(0,i.kt)("li",{parentName:"ul"},"13:00 - Network is all operational, systems back to normal, gRPC back to 100%. However, only running with archival + experimental pods. Statefulset is still at 0 pods."),(0,i.kt)("li",{parentName:"ul"},"15:30 - Statefulset scaled back to 5")),(0,i.kt)("p",null,"11/24/2019"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"18:00 - Alert received for no finality in 10 Epochs."),(0,i.kt)("li",{parentName:"ul"},"19:20 - Terence confirm with Danny that the finality reversions we have been witnessing is indeed a spec bug. However, there isn\u2019t an easy fix that we can deploy immediately, so we will have to wait till the next release."),(0,i.kt)("li",{parentName:"ul"},"20:30 - Nishant points to a Pull Request that modified the logic behind our pending queues that could have been the cause of our finality issues.He then opens up a PR to revert it."),(0,i.kt)("li",{parentName:"ul"},"20:50 Preston rolls out the hotfix with the PR reverted to our experimental nodes."),(0,i.kt)("li",{parentName:"ul"},"21:30 Seeing as the rollout did not have any negative effect on our experimental nodes, Preston then pushes the hotfix to our production nodes."),(0,i.kt)("li",{parentName:"ul"},"22:30 The hotfix has been successfully rolled out"),(0,i.kt)("li",{parentName:"ul"},"23:30 We still get alerts with no finality for 10 epochs. Which means that the hotfix was unsuccessful.")),(0,i.kt)("p",null,"11/25/2019"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"0:30 After looking at all our previous PRs and observing network metrics for the past few days, Preston suggests that the main cause of our finality worries isn\u2019t a bad PR merged in , but instead the growth of the network. With peer counts increasing close to 70, each Agora node processes close to 200 attestations /sec"),(0,i.kt)("li",{parentName:"ul"},"1:00 Preston then checks Jaeger and see that a very large amount of time is spent on DB writes especially in updateAttVotes in OnAttestation. The span in Jaeger, supports this theory as it shows OnAttestation taking nearly 1s with the large majority being taken up by writing attestation data to disk. Initially it looked like an improper use of Batch Updates in Bolt."),(0,i.kt)("li",{parentName:"ul"},"1:10 After exploring the code in some more, Nishant finds the problem is not that but instead the fact that the function upateAttVotes is very heavy on disk I/O due to the latest vote being saved for each validator in the attestation. This coupled with the fact that the Agora node receives 200 attestations/sec , it would explain the large amounts of time being spent on db writes in Jaeger.")),(0,i.kt)("h4",{id:"supporting-information-1"},"Supporting information"),(0,i.kt)("p",null,"Statefulset prod pods being stuck even after a rollout of a previous image was completed - pods showed no error logs but after finishing regular sync, they were unhealthy and were unable to serve traffic to validators. Archival+experimental pods were properly carrying out the chain on their own."),(0,i.kt)("h3",{id:"finality-decreased-incident-3"},"Finality Decreased! (Incident #3)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 2019/11/21"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Preston, Terence"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Mitigated; In root cause investigation"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," Agora-cl nodes observed a finalized checkpoint reversion which caused all attestations to be rejected."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," 56 epochs gap in finality"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," Agora-cl clients experienced a spec allowed finality reversion during a forking condition. Agora-cl\u2019s chain service maintains the most recent finalized checkpoint and has validation to ensure a finalized checkpoint can never revert. This led to a difference in finalized checkpoints between the chain service cache and the head state. All incoming attestations were validated and rejected based on the chain service checkpoint."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," Finality decreases"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," TBD -- Fix the condition for updating finalized check point cache"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," Prometheus, pager"),(0,i.kt)("h4",{id:"action-items"},"Action Items"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Confirm finality roll back is normal")),(0,i.kt)("p",null,"Confirmed it\u2019s not normal. From Danny: The fork choice first narrows down the block tree by finality, then narrows it down by latest justified. In the above scenario, the block at slot x+8 should not even be considered in the fork choice"),(0,i.kt)("h4",{id:"lessons-learned-2"},"Lessons Learned"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went well"),"\nThe ability to extract offender DB and play back these scenarios is very helpful\nPrometheus graphs helped to narrow down the problem"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went wrong"),"\nLack of metrics. For a single entry, we often have to consider 2 values. The latest value, and the cached value. In this case, we only captured the latest value"),(0,i.kt)("h4",{id:"timeline-4"},"Timeline"),(0,i.kt)("p",null,"2019-11-21 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"23:35:26 - Received  block 74137 with pre state of slot 74132. The pre state has finalized epoch is 9264."),(0,i.kt)("li",{parentName:"ul"},"23:35:26~23:36:50 - No blocks received."),(0,i.kt)("li",{parentName:"ul"},"23:36:50 - Received block 74144 with pre state of slot 74130 (in epoch 9266). The pre state has finalized epoch 9263. Attestations favored block from 74144 and made post state of slot 74144 the head state which has finalized epoch 9263. Database headState was updated where the finalized epoch is now 9263. ChainService.HeadState (cache) is also updated with the new state with finalized epoch of 9263. The chain service FinalizedCheckpt was not updated due to an enforcement that the finalized checkpoint cannot drop."),(0,i.kt)("li",{parentName:"ul"},"23:37 - Prometheus observed finalized epoch drop from 9264 to 9263. Link. This affected all Prylabs nodes at the same time."),(0,i.kt)("li",{parentName:"ul"},"23:37 - P2P attestations in Agora chain nodes that attestations were \u201cold\u201d since their source was 6264. Nodes were producing attestations with the finalized checkpoint epoch at 9263, but nodes were validating them in p2p against 9264."),(0,i.kt)("li",{parentName:"ul"},"23:47 - Page is received. Preston begins investigation.")),(0,i.kt)("p",null,"2019-11-22"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"00:00 - Preston suspects something is going on with the finalized checkpoint."),(0,i.kt)("li",{parentName:"ul"},"~00:10 - Normal canary rollout proceeds. Node restarts are welcome to flush any cache."),(0,i.kt)("li",{parentName:"ul"},"~00:25 - Rollout complete, problem persists."),(0,i.kt)("li",{parentName:"ul"},"00:40 - Preston suspects the finalized checkpoint in the chain info reverted but the checkpoint in the head state did not. This line of code seemed to be the cause of our attestations being rejected."),(0,i.kt)("li",{parentName:"ul"},"00:44 - Hotfix patch rollout begins. (See supporting info for patch details)."),(0,i.kt)("li",{parentName:"ul"},"00:55 - Rollout complete, 1 pod struggling. Experimental, archival deployments scaled down."),(0,i.kt)("li",{parentName:"ul"},"00:58 - Justification"),(0,i.kt)("li",{parentName:"ul"},"01:00 - Finalization"),(0,i.kt)("li",{parentName:"ul"},"01:00 - Hotfix patch is rolled back. Experimental, archival deployments scaled up."),(0,i.kt)("li",{parentName:"ul"},"01:04 - Problem mitigation ends and root cause investigation begins.")),(0,i.kt)("h4",{id:"supporting-information-2"},"Supporting information"),(0,i.kt)("p",null,"Supporting test: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/zeroone-boa/agora-cl/blob/454c7d70e69e98e39d26f862c306b352a5381f08/beacon-chain/core/state/transition_test.go#L1109"},"https://github.com/zeroone-boa/agora-cl/blob/454c7d70e69e98e39d26f862c306b352a5381f08/beacon-chain/core/state/transition_test.go#L1109")),(0,i.kt)("p",null,"Additional supporting data: ",(0,i.kt)("a",{parentName:"p",href:"https://gist.github.com/prestonvanloon/365cc64804b46bd65790ba898cf60e1b"},"https://gist.github.com/prestonvanloon/365cc64804b46bd65790ba898cf60e1b")),(0,i.kt)("p",null,"Hotfix patch that was applied:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"diff --git a/beacon-chain/sync/validate_beacon_attestation.go b/beacon-chain/sync/validate_beacon_attestation.go\nindex 30671f9b9..9684609c8 100644\n--- a/beacon-chain/sync/validate_beacon_attestation.go\n+++ b/beacon-chain/sync/validate_beacon_attestation.go\n@@ -65,7 +65,11 @@ func (r *RegularSync) validateBeaconAttestation(ctx context.Context, msg proto.M\n                return false, nil\n        }\n\n-       finalizedEpoch := r.chain.FinalizedCheckpt().Epoch\n+       head, err := r.db.HeadState(ctx)\n+       if err != nil {\n+               return false, err\n+       }\n+       finalizedEpoch := head.FinalizedCheckpoint.Epoch\n        attestationDataEpochOld := finalizedEpoch >= att.Data.Source.Epoch || finalizedEpoch >= att.Data.Target.Epoch\n        if finalizedEpoch != 0 && attestationDataEpochOld {\n                log.WithFields(logrus.Fields{\n(END)\n")),(0,i.kt)("p",null,"Conversation with Danny:\nDanny Ryan, ","[Nov 24, 2019 at 11:16:04 AM]",":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Check block is a descendant of the finalized block\n    assert (\n        get_ancestor(store, signing_root(block), store.blocks[store.finalized_checkpoint.root].slot) ==\n        store.finalized_checkpoint.root\n    )\n")),(0,i.kt)("p",null,"should prevent adding new blocks that are not descendants of the finalized block."),(0,i.kt)("p",null,"There is a corner case in which a branch might have the finalized block but not enough votes on the branch to have ",(0,i.kt)("em",{parentName:"p"},"finalized")," the block. Such a case does not currently have a fix in the spec, but the fix you added doesn\u2019t properly cover this case because it cuts out possible branches that ",(0,i.kt)("em",{parentName:"p"},"might")," finalize the root in the future (include proper amount of attestations)."),(0,i.kt)("p",null,"We\u2019ve been talking about this scenario the past week. Not 100% sure the scenario you found is the same"),(0,i.kt)("p",null,"regardless, the following should prevent you from finalizing an older epoch in any possible case"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Update finalized checkpoint\n    if state.finalized_checkpoint.epoch > store.finalized_checkpoint.epoch:\n        store.finalized_checkpoint = state.finalized_checkpoint\n\nyou _never_ finalize an older epoch in on_block, and get_head filters out blocks that aren\u2019t in your the block tree rooted at your latest justified\n")),(0,i.kt)("p",null,"Terence Tsao, ","[Nov 24, 2019 at 11:35:13 AM]",":\nBut wouldn\u2019t you want to prevent adding new block that\u2019s not descendent of the \u201clatest\u201d finalized block? Here\u2019s what happened in our node:"),(0,i.kt)("p",null,'After processing b144, store.finalized_epoch is 4 because it cant be reverted given the "update finalized checkpoint..." condition. But head_state.finalized_epoch got reverted to 3'),(0,i.kt)("p",null,'The "descendant of the finalized block..." check doesn\'t cover this case because block111 (finalized epoch 4) is also a descendent of b101 (finalized epoch 3)'),(0,i.kt)("p",null,'Only thing I think of is get_head did not filter out b144 based on "block tree rooted at your latest justified..." condition\u2026 I\u2019ll check that now'),(0,i.kt)("h3",{id:"goerli--pow-nodes-offline-killed-testnet-incident-2"},"Goerli / PoW Nodes Offline Killed Testnet (Incident #2)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 2019/10/30"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Preston and Nishant"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Action items in progress"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," Goerli PoW test network experienced a hard fork which the Agora-cl testnet nodes were not compatible with. As a result, all connections to Goerli PoW chain from Agora-cl nodes failed and the condition could not be recovered before too many epochs had lapsed to the point that Agora-cl can not compute assignments fast enough."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," Agora-cl testnet stalled for 2 hours. Committee assignments could not be calculated within adequate time without substantial code changes. Agora-cl testnet required a restart."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," Tight coupling with PoW. Committee assignments fail to compute within a short deadline."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," Istanbul hardfork on Goerli."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," Full testnet restart, scheduled for November 4th."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," Ping on twitter / gitter / discord. Chain stalled alert."),(0,i.kt)("h4",{id:"lessons-learned-3"},"Lessons Learned"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went well")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"go-ethereum was able to sync Goerli in under 15 minutes.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went wrong")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Critical monitoring alerts didn\u2019t fire with missing data."),(0,i.kt)("li",{parentName:"ul"},"Lack of communication between Prysmatic Labs and Goerli community caused an easily preventable issue."),(0,i.kt)("li",{parentName:"ul"},"Inability to start without ETH1 caused the chain to be 100% offline.")),(0,i.kt)("h4",{id:"where-we-got-lucky-4"},"Where we got lucky"),(0,i.kt)("p",null,"This incident exposes a single point of failure with PoW: Agora-cl nodes could not start without an existing PoW connection, despite being recently synced."),(0,i.kt)("h4",{id:"timeline-5"},"Timeline"),(0,i.kt)("p",null,"2019-10-30 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"13:36 soc1c announces hardfork happens within one hour."),(0,i.kt)("li",{parentName:"ul"},"13:53 Istanbul hardfork happens at block 1561651. All of Agora-cl goerli nodes were not compatible and could not advance the chain."),(0,i.kt)("li",{parentName:"ul"},"~13:55 Beacon chain nodes stop serving traffic. All are reporting unhealthy due to lack of  healthyETH1 connection."),(0,i.kt)("li",{parentName:"ul"},"14:05 Chain starts to stall. See chart."),(0,i.kt)("li",{parentName:"ul"},"~14:10 Beacon chain nodes have been unhealthy for too long. Kubernetes scheduler starts to reschedule the pods, but pods cannot start."),(0,i.kt)("li",{parentName:"ul"},"14:13 Chain stall metric drops off with no data. Presumably because all Agora chain nodes are dead and the metric is not being scraped/reported."),(0,i.kt)("li",{parentName:"ul"},"15:11 Peter reaches out on twitter."),(0,i.kt)("li",{parentName:"ul"},"15:11 Chain stalled alert fired."),(0,i.kt)("li",{parentName:"ul"},"15:16 Chain stalled alert resolved. (Due to lack of data)."),(0,i.kt)("li",{parentName:"ul"},"16:00 Prysmatic Goerli nodes updated, syncing from genesis."),(0,i.kt)("li",{parentName:"ul"},"16:10 Prysmatic Goerli nodes back online."),(0,i.kt)("li",{parentName:"ul"},"~16:12 Hacked image deployed to be immediately in sync."),(0,i.kt)("li",{parentName:"ul"},"16:14 Agora-cl nodes can start again and come online."),(0,i.kt)("li",{parentName:"ul"},"~16:14 A beacon block is produced, stalled chain event fires again."),(0,i.kt)("li",{parentName:"ul"},"16:22 All Agora-cl nodes back online, except prod-4 and prod-1(expected those are stuck due to issue 3885)."),(0,i.kt)("li",{parentName:"ul"},"~16:22 Hacked image rolled back."),(0,i.kt)("li",{parentName:"ul"},"16:31 Nishant observes deadline exceeded at high rate for committee assignments. The chain is considered unrecoverable."),(0,i.kt)("li",{parentName:"ul"},"16:31 Investigation ends.")),(0,i.kt)("h3",{id:"testnet-large-finality-gap-postmortem-incident-1"},"Testnet Large Finality Gap Postmortem (Incident #1)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Date:")," 2019-10-27"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Authors:")," Preston Van Loon"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Status:")," Draft"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Summary:")," A seemingly benign production rollout uncovered a cascading series of errors which led to a large gap in finalized epochs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Impact:")," 86 consecutive epochs without finality."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Root Causes:")," Offline validators, forked Agora chain pods."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Trigger:")," A successful 3 hour canary report started a rollout to production and experimental pods."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Resolution:")," Validators were penalized and ejected until finality could be reached."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Detection:")," Prometheus alarm for too_long_since_finality_10."),(0,i.kt)("h4",{id:"lessons-learned-4"},"Lessons Learned"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went well"),"\nFinality alert notified on call and response time was less than a minute."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"What went wrong")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"There are multiple issues causing finality gap and it was hard to isolate the problem."),(0,i.kt)("li",{parentName:"ul"},"We allowed too many external peers to join the testnet and go offline. At the time of the event, we only controlled 70% of active validators which is dangerously close to falling under 2/3rds majority. Given the ephemeral nature of external testers, we can assume that the majority of validators not controlled by Prysmatic Labs are offline. Any issue in the network is extra sensitive to finality gaps."),(0,i.kt)("li",{parentName:"ul"},"There is an existing bug where non-canonical blocks are served on p2p RPC requests for blocks by range. This is blocking testnet users from syncing to head and is blocking normal rollout procedures for beacon-chain-prod-1.")),(0,i.kt)("h4",{id:"where-we-got-lucky-5"},"Where we got lucky"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Some validators were close to ejection. After enough of the exponential penalties, the network was able to reach finality. Had this event continued beyond 100 epochs, it is very likely that we would not have been able to recover due to timeouts in committeeAssignment requests as it grows more expensive as the gap in finality increases.")),(0,i.kt)("h4",{id:"timeline-6"},"Timeline"),(0,i.kt)("p",null,"2019-10-27 (all times UTC)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"3:47:11 Canary pipeline starts."),(0,i.kt)("li",{parentName:"ul"},"7:09:34 Prod pods deployment starts."),(0,i.kt)("li",{parentName:"ul"},"7:09:34 Experimental pods deployment starts."),(0,i.kt)("li",{parentName:"ul"},"7:13:00 beacon-chain-experimental-6dcdd678d4-2j2vp, beacon-chain-experimental-6dcdd678d4-s62lv, and beacon-chain-canary-5b4c95f7f6-nf8st starts logging \u201ccould not verify indexed attestation: attestation aggregation signature did not verify\u201d at 5 to 15 times per minute until 7:40:00."),(0,i.kt)("li",{parentName:"ul"},"7:14:24 First sign of issues in finality. 6.785 epochs since last finality. Finality is reached."),(0,i.kt)("li",{parentName:"ul"},"7:14:52 Finalized epoch reaches 17332, then drops to 17331."),(0,i.kt)("li",{parentName:"ul"},"7:16:16 beacon-chain-experimental-6dcdd678d4-s62lv experiences less than 95% gRPC success rate for ProposeBlock. This pod is running the new image from rollout."),(0,i.kt)("li",{parentName:"ul"},"7:16:44 Finalized epoch reaches 17332, then drops to 17331."),(0,i.kt)("li",{parentName:"ul"},"7:19:32 beacon-chain-prod-0 experiences less than 95% gRPC success rate for ProposeBlock. This pod is running the old image and has not been restarted in over two days due to a stuck rollout with prod-1."),(0,i.kt)("li",{parentName:"ul"},"7:19:32 beacon-chain-prod-2 experiences less than 95% gRPC success rate for ProposeBlock. Uncertain if this pod was recently restarted or running old image."),(0,i.kt)("li",{parentName:"ul"},"7:19:32 Several pods experience high rate of p2p processing failures on beacon block gossip topic."),(0,i.kt)("li",{parentName:"ul"},"7:20:00 too_long_since_finality_10 alert starts."),(0,i.kt)("li",{parentName:"ul"},"7:20:00 Preston ACKs alert and begins investigation."),(0,i.kt)("li",{parentName:"ul"},"7:27:00 Preston observes block proposals are failing on three pods."),(0,i.kt)("li",{parentName:"ul"},"7:27:00 Preston observes finalized_epoch metric drop by 1."),(0,i.kt)("li",{parentName:"ul"},"7:33:04 Finality is reached again. This gap was 26 epochs."),(0,i.kt)("li",{parentName:"ul"},"7:37:00 Preston observes many \u201ccould not verify indexed attestation: attestation aggregation signature did not verify\u201d errors from receiving attestations of p2p."),(0,i.kt)("li",{parentName:"ul"},"7:40:00 Preston scales experimental pods to 0."),(0,i.kt)("li",{parentName:"ul"},"7:45:00 Preston pauses canary pipeline and cancels currently running canary. Canary pod is deleted."),(0,i.kt)("li",{parentName:"ul"},"8:38:52 Finality is reached. This gap was 86 epochs."),(0,i.kt)("li",{parentName:"ul"},"8:44:00 Investigation ends.")))}h.isMDXComponent=!0}}]);